{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Pengenalan \u00b6 Di web ini akan dimasukkan beberapa informasi tentang dunia IT dan dokumentasi pembelajaran. Sejarah \u00b6 MalingIT adalah sebuah komunitas yang didirikan pada 22 Februari 2021 di telegram. Pada awalnya maling-it didirikan untuk mengumpulkan pdf atau ebook tentang programming dan komputer yang sudah ada di beberapa channel telegram yang membahas hal tersebut. Selanjutnya pada 18 Mei 2021 Maling-it menambahkan bot untuk mempermudah pencarian file yang dikirim ke channel telegram. Itu adalah sejarah singkatnya dari maling-it, sebenarnya ceritanya cukup panjang dan mungkin akan diupdate lagi di kemudian hari. Filosofi \u00b6 Menurut KBBI, Maling artinya adalah orang yang mencuri secara sembunyi-sembunyi, sedangkan IT adalah kependekan dari Informasi Teknologi. Jadi dapat disimpulkan bahwa Maling IT merupakan salah satu channel yang mengumpulkan file-file dari channel telegram yang lain (niat hati mengumpulkan dan menjadi maling modern). Selain itu, menurut member juga menyebutkan bahwa Maling IT adalah Perpustakaan elektronik yang menyediakan buku-buku programming secara gratis. Kontribusi \u00b6 Jika menemukan kesalahan dalam penulisan kata atau ingin menambahkan konten baru, silahkan buat perubahan. Anda juga bisa menggunakan tombol dibagian kanan atas di setiap artikel/konten untuk menambahkan ke pull request. Jika tidak tau apa maksudnya, anda juga bisa membuat issue atau kirim email. Terimakasih \u00b6 Jika anda suka dengan artikel atau konten dari kami dan ingin menunjukkan support, silahkan lihat bagian donasi atau kontribusi di beberapa projek maling-it.","title":"Pengenalan"},{"location":"#pengenalan","text":"Di web ini akan dimasukkan beberapa informasi tentang dunia IT dan dokumentasi pembelajaran.","title":"Pengenalan"},{"location":"#sejarah","text":"MalingIT adalah sebuah komunitas yang didirikan pada 22 Februari 2021 di telegram. Pada awalnya maling-it didirikan untuk mengumpulkan pdf atau ebook tentang programming dan komputer yang sudah ada di beberapa channel telegram yang membahas hal tersebut. Selanjutnya pada 18 Mei 2021 Maling-it menambahkan bot untuk mempermudah pencarian file yang dikirim ke channel telegram. Itu adalah sejarah singkatnya dari maling-it, sebenarnya ceritanya cukup panjang dan mungkin akan diupdate lagi di kemudian hari.","title":"Sejarah"},{"location":"#filosofi","text":"Menurut KBBI, Maling artinya adalah orang yang mencuri secara sembunyi-sembunyi, sedangkan IT adalah kependekan dari Informasi Teknologi. Jadi dapat disimpulkan bahwa Maling IT merupakan salah satu channel yang mengumpulkan file-file dari channel telegram yang lain (niat hati mengumpulkan dan menjadi maling modern). Selain itu, menurut member juga menyebutkan bahwa Maling IT adalah Perpustakaan elektronik yang menyediakan buku-buku programming secara gratis.","title":"Filosofi"},{"location":"#kontribusi","text":"Jika menemukan kesalahan dalam penulisan kata atau ingin menambahkan konten baru, silahkan buat perubahan. Anda juga bisa menggunakan tombol dibagian kanan atas di setiap artikel/konten untuk menambahkan ke pull request. Jika tidak tau apa maksudnya, anda juga bisa membuat issue atau kirim email.","title":"Kontribusi"},{"location":"#terimakasih","text":"Jika anda suka dengan artikel atau konten dari kami dan ingin menunjukkan support, silahkan lihat bagian donasi atau kontribusi di beberapa projek maling-it.","title":"Terimakasih"},{"location":"komunitas/","text":"Komunitas \u00b6 Tempat diskusi dan bertanya: Telegram: @RumahMalingIT Forum Github: Link","title":"Komunitas"},{"location":"komunitas/#komunitas","text":"Tempat diskusi dan bertanya: Telegram: @RumahMalingIT Forum Github: Link","title":"Komunitas"},{"location":"kontak/","text":"Kontak \u00b6 Hubungi admin: Email: zxce3 at protonmail.com Telegram: @zxce3","title":"Kontak"},{"location":"kontak/#kontak","text":"Hubungi admin: Email: zxce3 at protonmail.com Telegram: @zxce3","title":"Kontak"},{"location":"legal-notice/","text":"English Indonesia This website is a place for learning for the public and also for sharing files that to our knowledge have been INTENTIONALY made public by the copyright holders. If this website has shared files that have violated your rights as a copyright holder, you can contact zxce3@protonmail.com via email or contact @Zxce3 via telegram to request deleting files that are considered to infringe your copyright. We only delete files from this website, namely the m-it.my.id website as under our control. However, we have no control over the destination of the file and/or have no control over removing the content from the internet or the original source of the file. We accept all complaints and suggestions for the future. Best regards Zxce3 Website ini adalah tempat belajar untuk umum dan juga membagikan file yang sepengetahuan kami telah SENGAJA dibuat publik oleh pemegang hak cipta. Jika website ini telah membagikan file yang telah melanggar hak Anda sebagai pemegang hak cipta, Anda dapat menghubungi dengan email ke zxce3@protonmail.com atau melalui kontak telegram @Zxce3 untuk meminta menghapus file yang dianggap melanggar hak cipta Anda. Kami hanya menghapus file dari website ini yaitu website m-it.my.id selaku berada dibawah kuasa kami. Namun, kami tidak memiliki kendali atas tujuan file tersebut dan/atau tidak memiliki kendali untuk menghapus konten dari internet atau sumber asli file tersebut. Kami menerima segala keluhan dan saran untuk kedepannya. Hormat kami Zxce3","title":"Legal Notice"},{"location":"belajar/","text":"Belajar \u00b6 Note Dokumentasi belajar yang dikumpulkan dari berbagai sumber web maupun pdf seputar programming dan teknologi Git Shell","title":"Belajar"},{"location":"belajar/#belajar","text":"Note Dokumentasi belajar yang dikumpulkan dari berbagai sumber web maupun pdf seputar programming dan teknologi Git Shell","title":"Belajar"},{"location":"belajar/git/","text":"Belajar Git \u00b6 Note sumber panduan ini dari https://git-scm.com/book/id/v2/ Apa itu git? \u00b6 Saat ini, ada banyak tools yang digunakan oleh programmer dan developer. Salah satunya adalah Git yang menjadi tool penting dalam pengembangan sebuah website. Jangan keliru, Git bukan merupakan bahasa pemograman, tetapi sangat penting bagi programmer yang bekerja di hampir semua bahasa pemrograman. Untuk mengetahui apa itu Git, Anda perlu mengetahui fungsi Git yaitu sebagai control system untuk menjalankan proyek pengembangan software. Git merupakan tool yang dikembangkan oleh pengembang sistem kernel dari sistem operasi Linux yaitu Linus Torvalds pada tahun 2005. Berbasis pengontrol versi atau Version Control System (VCS), Git bertugas untuk mencatat perubahan seluruh file atau repository dari suatu project baik besar maupun kecil. Tujuan penggunaan Git untuk mengelola versi source code program dengan menentukan baris dan kode yang akan ditambah atau diganti. Ada ratusan proyek software yang mengandalkan Git sebagai version control system mereka, termasuk proyek komersial serta open source. Biasanya developer software menggunakan Git untuk distributed version control (VCS terdistribusi) yang bertujuan untuk menyimpan database tidak hanya ke satu tempat saja. Namun, semua orang yang terlibat dalam penyusunan kode dapat menyimpan database ini. Prosedur yang diterapkan ini dapat membantu antar divisi project untuk memantau dan menghubungkan (merge) antar ekstensi yang berbeda dengan mudah. Sehingga, aplikasi yang dibuat oleh sebuah tim project dapat berfungsi tanpa menghubungkan secara manual. Fitur pada Git \u00b6 Anda perlu mengetahui fitur-fitur yang terdapat pada Git, yaitu: 1. Distributed System Dengan sistem ini, Git memungkinkan pengguna untuk bekerja secara bersamaan pada project yang sama dari seluruh dunia, tanpa menggangu pekerjaan orang lain. 2. Branching Dengan Git, maka membuat, menghapus atau menggabungkan branch akan lebih cepat, lancar dan tidak memakan banyak waktu. Hal ini juga memungkinkan para developer memiliki branch code yang independent dan massive. 3. Open-source Git merupakan open-source karena memberikan fleksibilitas untuk memodifikasi kode sumbernya sesuai dengan kebutuhan pengguna atau kebutuhan dari developer. Selain itu, memungkinkan banyak orang untuk bekerja pada proyek yang sama dan bekerja sama satu sama lain dengan sangat efisien. Hal ii dirancang sedemikian rupa sehingga dapat menangani proyek-proyek kecil dan besar dengan mudah. 4. Version Control System yang terdistribusi Git menggunakan pendekatan yang disebut peer-to-peer yang berbeda dengan metode lain seperti subversion atau SVN yang menggunakan model client-server. 5. Non-linear development Git memungkinkan pengguna dari seluruh dunia untuk melakukan operasi pada project dari jarak jauh. Seorang pengguna dapat mengambil bagian mana pun dari proyek dan melakukan operasi yang diperlukan dan kemudian memperbarui project lebih lanjut. Hal ini dapat dilakukan dengan non-linear development. 6. Penyimpanan media berada pada folder .git Hal ini tentu berbeda dengan VCS lain contohnya seperti SVN atau CVS. Karena metadata file yang sudah disimpan dalam sebuah folder tersembunyi. Contohnya seperti .cvs, .svn, .etc. 7. Lightweight Git menyimpan semua data dari repository pusat ke repository local saat cloning selesai. Hal ini memungkinkan ada ratusan pengguna yang mengerjakan proyek yang sama dan karenanya data pada repository pusat akan sangat besar. Git memiliki fitur lossless compression data yang dapat mengompresi data menjadi sangat minim dan menyimpannya di repository local. 8. Staging Area atau Index Git memiliki staging area, dengan begitu developer akan dapat memformat commit atau bisa juga membuatnya agar dapat di-review sebelum akhirnya diterapkan secara benar. Manfaat Git \u00b6 1. Memudahkan dalam berkolaborasi dalam satu atau lebih project Dengan Git, akan sangat memudahkan para developer untuk berpartisipasi dalam sebuah pengembangan project yang dilakukan oleh orang-orang. 2. Memudahkan programmer untuk mengetahui perubahan source codenya Anda tidak perlu membuat file baru yang jumlahnya banyak dengan nama yang berbeda karena dengan Git programmer dapat medeteksi secara langsung perubahan yang ada. Terdapat istilah commit pada Git yang berfungsi untuk menyimpan riwayat perubahan data pada file. Melalui commit, developer dapat kembali ke source code sebelumnya dengan istilah checkout. Selain itu, Git menyimpan seluruh versi source code. 3. Dapat disimpan dengan offline ataupun online Untuk mengoperasikan Git, Anda perlu menginstall software terlebih dahulu sehingga pekerjaan ini dapat dilakukan secara offline (tidak terkoneksi internet). Software ini juga tersedia secara gratis melalui web unduhan resminya di Git Downloading. Kesimpulan \u00b6 Setelah mengetahui apa itu Git, fungsi, dan manfaatnya. Dapat diketahui juga Git merupakan version control system paling populer digunakan saat ini, terdapat ratusan proyek software yang mengandalkan Git, sehingga dapat dikatakan Git adalah sebuah tools yang diperlukan oleh para developer atau programmer.","title":"Git V1"},{"location":"belajar/git/#belajar-git","text":"Note sumber panduan ini dari https://git-scm.com/book/id/v2/","title":"Belajar Git"},{"location":"belajar/git/#apa-itu-git","text":"Saat ini, ada banyak tools yang digunakan oleh programmer dan developer. Salah satunya adalah Git yang menjadi tool penting dalam pengembangan sebuah website. Jangan keliru, Git bukan merupakan bahasa pemograman, tetapi sangat penting bagi programmer yang bekerja di hampir semua bahasa pemrograman. Untuk mengetahui apa itu Git, Anda perlu mengetahui fungsi Git yaitu sebagai control system untuk menjalankan proyek pengembangan software. Git merupakan tool yang dikembangkan oleh pengembang sistem kernel dari sistem operasi Linux yaitu Linus Torvalds pada tahun 2005. Berbasis pengontrol versi atau Version Control System (VCS), Git bertugas untuk mencatat perubahan seluruh file atau repository dari suatu project baik besar maupun kecil. Tujuan penggunaan Git untuk mengelola versi source code program dengan menentukan baris dan kode yang akan ditambah atau diganti. Ada ratusan proyek software yang mengandalkan Git sebagai version control system mereka, termasuk proyek komersial serta open source. Biasanya developer software menggunakan Git untuk distributed version control (VCS terdistribusi) yang bertujuan untuk menyimpan database tidak hanya ke satu tempat saja. Namun, semua orang yang terlibat dalam penyusunan kode dapat menyimpan database ini. Prosedur yang diterapkan ini dapat membantu antar divisi project untuk memantau dan menghubungkan (merge) antar ekstensi yang berbeda dengan mudah. Sehingga, aplikasi yang dibuat oleh sebuah tim project dapat berfungsi tanpa menghubungkan secara manual.","title":"Apa itu git?"},{"location":"belajar/git/#fitur-pada-git","text":"Anda perlu mengetahui fitur-fitur yang terdapat pada Git, yaitu: 1. Distributed System Dengan sistem ini, Git memungkinkan pengguna untuk bekerja secara bersamaan pada project yang sama dari seluruh dunia, tanpa menggangu pekerjaan orang lain. 2. Branching Dengan Git, maka membuat, menghapus atau menggabungkan branch akan lebih cepat, lancar dan tidak memakan banyak waktu. Hal ini juga memungkinkan para developer memiliki branch code yang independent dan massive. 3. Open-source Git merupakan open-source karena memberikan fleksibilitas untuk memodifikasi kode sumbernya sesuai dengan kebutuhan pengguna atau kebutuhan dari developer. Selain itu, memungkinkan banyak orang untuk bekerja pada proyek yang sama dan bekerja sama satu sama lain dengan sangat efisien. Hal ii dirancang sedemikian rupa sehingga dapat menangani proyek-proyek kecil dan besar dengan mudah. 4. Version Control System yang terdistribusi Git menggunakan pendekatan yang disebut peer-to-peer yang berbeda dengan metode lain seperti subversion atau SVN yang menggunakan model client-server. 5. Non-linear development Git memungkinkan pengguna dari seluruh dunia untuk melakukan operasi pada project dari jarak jauh. Seorang pengguna dapat mengambil bagian mana pun dari proyek dan melakukan operasi yang diperlukan dan kemudian memperbarui project lebih lanjut. Hal ini dapat dilakukan dengan non-linear development. 6. Penyimpanan media berada pada folder .git Hal ini tentu berbeda dengan VCS lain contohnya seperti SVN atau CVS. Karena metadata file yang sudah disimpan dalam sebuah folder tersembunyi. Contohnya seperti .cvs, .svn, .etc. 7. Lightweight Git menyimpan semua data dari repository pusat ke repository local saat cloning selesai. Hal ini memungkinkan ada ratusan pengguna yang mengerjakan proyek yang sama dan karenanya data pada repository pusat akan sangat besar. Git memiliki fitur lossless compression data yang dapat mengompresi data menjadi sangat minim dan menyimpannya di repository local. 8. Staging Area atau Index Git memiliki staging area, dengan begitu developer akan dapat memformat commit atau bisa juga membuatnya agar dapat di-review sebelum akhirnya diterapkan secara benar.","title":"Fitur pada Git"},{"location":"belajar/git/#manfaat-git","text":"1. Memudahkan dalam berkolaborasi dalam satu atau lebih project Dengan Git, akan sangat memudahkan para developer untuk berpartisipasi dalam sebuah pengembangan project yang dilakukan oleh orang-orang. 2. Memudahkan programmer untuk mengetahui perubahan source codenya Anda tidak perlu membuat file baru yang jumlahnya banyak dengan nama yang berbeda karena dengan Git programmer dapat medeteksi secara langsung perubahan yang ada. Terdapat istilah commit pada Git yang berfungsi untuk menyimpan riwayat perubahan data pada file. Melalui commit, developer dapat kembali ke source code sebelumnya dengan istilah checkout. Selain itu, Git menyimpan seluruh versi source code. 3. Dapat disimpan dengan offline ataupun online Untuk mengoperasikan Git, Anda perlu menginstall software terlebih dahulu sehingga pekerjaan ini dapat dilakukan secara offline (tidak terkoneksi internet). Software ini juga tersedia secara gratis melalui web unduhan resminya di Git Downloading.","title":"Manfaat Git"},{"location":"belajar/git/#kesimpulan","text":"Setelah mengetahui apa itu Git, fungsi, dan manfaatnya. Dapat diketahui juga Git merupakan version control system paling populer digunakan saat ini, terdapat ratusan proyek software yang mengandalkan Git, sehingga dapat dikatakan Git adalah sebuah tools yang diperlukan oleh para developer atau programmer.","title":"Kesimpulan"},{"location":"belajar/git/bantuan/","text":"Mendapatkan Bantuan \u00b6 Jika Anda memerlukan bantuan ketika menggunakan Git, ada tiga cara untuk mendapatkan halaman petunjuk bantuan ( manual page atau manpage) untuk sebarang perintah Git: git help <verb> git <verb> --help man git-<verb> Sebagai contoh, Anda dapat mendapatkan bantuan untuk perintah config dengan menjalankan git help config Perintah-perintah tersebut bagus, karena Anda dapat mendapatkannya di mana saja, bahkan ketika luring. Jika manpage dan buku ini tidak cukup dan Anda memerlukan bantuan secara langsung, Anda dapat mencoba kanal #git atau #github pada server Freenode IRC (irc.freenode.net) . Kanal-kanal tersebut diisi oleh ratusan orang yang sangat memahami tentang Git secara rutin dan seringkali bersedia untuk membantu.","title":"Bantuan"},{"location":"belajar/git/bantuan/#mendapatkan-bantuan","text":"Jika Anda memerlukan bantuan ketika menggunakan Git, ada tiga cara untuk mendapatkan halaman petunjuk bantuan ( manual page atau manpage) untuk sebarang perintah Git: git help <verb> git <verb> --help man git-<verb> Sebagai contoh, Anda dapat mendapatkan bantuan untuk perintah config dengan menjalankan git help config Perintah-perintah tersebut bagus, karena Anda dapat mendapatkannya di mana saja, bahkan ketika luring. Jika manpage dan buku ini tidak cukup dan Anda memerlukan bantuan secara langsung, Anda dapat mencoba kanal #git atau #github pada server Freenode IRC (irc.freenode.net) . Kanal-kanal tersebut diisi oleh ratusan orang yang sangat memahami tentang Git secara rutin dan seringkali bersedia untuk membantu.","title":"Mendapatkan Bantuan"},{"location":"belajar/git/command-line/","text":"Command Line \u00b6 Ada banyak cara untuk menggunakan Git. Ada peralatan command line asli, dan ada banyak antarmuka grafis pengguna dari berbagai kemampuan. Untuk buku ini, kita akan menggunakan Git dengan command line . Sebagai contoh, command line adalah satu-satunya cara agar Anda dapat menjalankan semua perintah-perintah Git \u2013 kebanyakan GUI hanya menerapkan beberapa subset dari kegunaan Git agar lebih mudah. Jika Anda tahu bagaimana cara menjalankan versi command line , mungkin Anda juga menemukan bagaimana cara menjalankan versi GUI , meski kebalikannya belum tentu benar. Juga, ketika pilihan klien grafis Anda adalah masalah kesenangan pribadi, semua pengguna akan memiliki peralatan command line terpasang dan tersedia. Jadi, kami akan mengharap Anda untuk tahu bagaimana cara membuka Terminal di Mac atau Command Prompt atau Powershell di Windows. Jika Anda tidak tahu tentang apa yang sedang kita bicarakan di sini, mungkin Anda perlu berhenti dan mempelajari hal itu secepatnya sehingga Anda dapat mengikuti semua contoh-contoh dan penjelasan pada buku ini.","title":"Command Line"},{"location":"belajar/git/command-line/#command-line","text":"Ada banyak cara untuk menggunakan Git. Ada peralatan command line asli, dan ada banyak antarmuka grafis pengguna dari berbagai kemampuan. Untuk buku ini, kita akan menggunakan Git dengan command line . Sebagai contoh, command line adalah satu-satunya cara agar Anda dapat menjalankan semua perintah-perintah Git \u2013 kebanyakan GUI hanya menerapkan beberapa subset dari kegunaan Git agar lebih mudah. Jika Anda tahu bagaimana cara menjalankan versi command line , mungkin Anda juga menemukan bagaimana cara menjalankan versi GUI , meski kebalikannya belum tentu benar. Juga, ketika pilihan klien grafis Anda adalah masalah kesenangan pribadi, semua pengguna akan memiliki peralatan command line terpasang dan tersedia. Jadi, kami akan mengharap Anda untuk tahu bagaimana cara membuka Terminal di Mac atau Command Prompt atau Powershell di Windows. Jika Anda tidak tahu tentang apa yang sedang kita bicarakan di sini, mungkin Anda perlu berhenti dan mempelajari hal itu secepatnya sehingga Anda dapat mengikuti semua contoh-contoh dan penjelasan pada buku ini.","title":"Command Line"},{"location":"belajar/git/dasar-git/","text":"Dasar-dasar Git \u00b6 Jadi, mudahnya, apakah Git itu? Ini adalah bab yang penting untuk dipahami, karena jika Anda memahami apa itu Git dan pemahaman dasar tentang bagaimana Git bekerja, maka, menggunakan Git dengan efektif mungkin akan menjadi lebih mudah Anda lakukan. Selama Anda belajar Git, cobalah untuk menjernihkan pikiran Anda dari hal-hal yang Anda ketahui tentang VCS lainnya, seperti Subversion dan Perforce; dengan begitu, akan membantu Anda menghindari hal-hal yang membingungkan ketika menggunakan alatnya. Git menyimpan dan berpikir tentang informasi dengan sangat berbeda daripada sistem lainnya, meskipun antarmuka penggunanya cukup mirip, dan memahami perbedaan-perbedaan tersebut akan membantu mencegah Anda menjadi bingung ketika menggunakannya. Snapshots, Bukan Perbedaan-perbedaan \u00b6 Perbedaan besar antara Git dan VCS lainnya (Subversion dan sejenisnya) adalah tentang cara Git berpikir tentang datanya. Secara konsep, kebanyakan sistem lain menyimpan informasi sebagai sebuah daftar dari perubahan-perubahan berbasis berkas. Sistem-sistem tersebut (CVS, Subversion, Perforce, Bazaar, dan seterusnya) berpikir tentang informasi yang mereka simpan sebagai sekumpulan berkas dan perubahan-perubahan yang dibuat kepada tiap berkas sepanjang waktu. graph LR A(Versi 1) --- A1(Versi 2) --- A2(Versi 3) --- A3(Versi 4) --- A4(Versi 5) B(File A) --> B1(#1) ---> B2(#2) C(File B) ----> C1(#1) --> C2(#2) D(File C) --> D1(#1) --> D2(#2) ---> D3(#3) Git tidak berpikir atau menyimpan datanya dengan cara ini. Namun, Git berpikir tentang datanya lebih seperti sekumpulan snapshot dari sebuah miniatur filesystem . Setiap kali Anda melakukan commit , atau menyimpan keadaan dari proyek Anda di Git, pada dasarnya itu mengambil sebuah gambar tentang bagaimana tampilan semua berkas Anda pada saat itu dan menyimpan acuan kepada snapshot tersebut. Singkatnya, jika berkas-berkas itu tidak berubah, Git tidak menyimpan berkasnya lagi, hanya menautkan ke berkas yang sama persis sebelumnya yang telah tersimpan. Git berpikir tentang datanya lebih seperti sebuah aliran snapshot . graph TD A(Versi 1) --- A1(File A) --- A2(File B) --- A3(File C) B(Versi 2) --- B1(A1) --- B2(B) --- B3(C1) C(Versi 3) --- C1(A1) --- C2(B) --- C3(C2) D(Versi 4) --- D1(A2) --- D2(B1) --- D3(C2) E(Versi 5) --- E1(A2) --- E2(B2) --- E3(C3) style B2 stroke-width:2px,stroke-dasharray: 5 5 style C1 stroke-width:2px,stroke-dasharray: 5 5 style C2 stroke-width:2px,stroke-dasharray: 5 5 style D3 stroke-width:2px,stroke-dasharray: 5 5 style E1 stroke-width:2px,stroke-dasharray: 5 5 Ini adalah perbedaan penting antara Git dan hampir semua VCS lainnya. Hal itu membuat Git mempertimbangkan ulang hampir semua aspek dari version control yang kebanyakan sistem lainnya tiru dari generasi sebelumnya. Ini membuat Git lebih seperti sebuah filesystem kecil dengan beberapa alat yang sangat hebat terpasang padanya, daripada hanya sebuah VCS sederhana. Kita akan menjelajahi beberapa keuntungan yang Anda dapatkan dengan berpikir tentang data Anda seperti ini ketika kami membahas percabangan Git pada Git Branching. Hampir Setiap Pekerjaan Adalah Lokal \u00b6 Kebanyakan pekerjaan pada Git hanya membutuhkan berkas-berkas dan sumber daya lokal untuk bekerja \u2013 secara umum, tidak ada informasi yang dibutuhkan dari komputer lain dalam jaringan Anda. Jika Anda terbiasa dengan CVCS di mana kebanyakan pekerjaan memiliki kelebihan network latency , aspek ini dalam Git akan membuat Anda berpikir bahwa Tuhan telah memberkati Git dengan kekuatan yang tak dapat diungkapkan dengan kata-kata. Karena, jika Anda memiliki seluruh riwayat proyek tepat berada di dalam local disk Anda, kebanyakan pekerjaan terlihat hampir dalam sekejap. Sebagai contoh, untuk meramban riwayat dari proyek, Git tidak perlu pergi ke server untuk mendapatkan riwayat dan menampilkannya kepada Anda \u2013 dia hanya membacanya langsung dari basis data lokal Anda. Ini berarti Anda melihat riwayat proyek hampir dalam sekejap. Jika Anda ingin melihat perubahan-perubahan yang dikenalkan antara versi sekarang dari sebuah berkas dan berkasnya pada saat sebulan yang lalu, Git dapat mencari berkasnya sebulan yang lalu dan melakukan perhitungan perbedaan secara lokal, bukannya meminta kepada remote server untuk melakukannya atau menarik versi lama dari berkas dari remote server untuk melakukannya secara lokal. Ini juga berarti bahwa hanya ada sedikit hal yang tidak dapat Anda lakukan ketika Anda berada di luar jaringan atau di luar VPN. Jika Anda sedang mengendarai pesawat terbang atau kereta dan ingin sedikit bekerja, Anda dapat melakukan commit dengan bahagia hingga Anda mendapat sambungan jaringan untuk mengunggah. Jika Anda pulang dan tidak dapat menggunakan klien VPN dengan wajar, Anda masih dapat bekerja. Pada banyak sistem lain, melakukan hal tersebut adalah tidak mungkin atau sangat susah. Pada Perforce, misalnya, Anda tidak dapat melakukan banyak hal ketika Anda tidak tersambung ke server ; dan pada Subversion dan CVS, Anda dapat menyunting berkas, namun Anda tidak dapat melakukan commit tentang perubahan-perubahan ke basis data Anda (karena basis data Anda sedang luring). Ini mungkin tidak terlihat seperti sebuah masalah, namun, Anda mungkin akan terkejut betapa besar perbedaan yang dapat dibuatnya. Git Memiliki Integritas \u00b6 Semuanya dalam Git telah dilakukan checksum sebelum itu disimpan dan kemudian mengacu pada checksum tersebut. Ini berarti bahwa tidak mungkin untuk mengubah isi dari sebarang berkas atau direktori tanpa diketahui oleh Git. Kemampuan ini terpasang pada Git pada tingkat paling bawah dan terpadu pada filosofinya. Anda tidak dapat kehilangan informasi dalam singgahan atau mendapat berkas yang corrupt yang tidak terlacak oleh Git. Cara kerja yang digunakan oleh Git untuk melakukan checksum disebut dengan SHA-1 hash . Ini adalah kumpulan kata sepanjang 40 karakter dari karakter heksadesimal (0-9 dan a-f) dan dihitung berdasarkan isi dari sebuah berkas atau struktur direktori dalam Git. Sebuah SHA-1 hash nampak seperti berikut: Contoh hash 24b9da6552252987aa493b52f8696cd6d3b00373 Anda akan melihat nilai hash tersebut di semua tempat pada Git karena dia sering menggunakannya. Nyatanya, Git menyimpan semuanya dalam basis datanya bukan dari nama berkas, namun dari nilai hash isinya. Git Umumnya Hanya Menambah Data \u00b6 Ketika Anda melakukan aksi dalam Git, hampir semuanya hanya menambahkan data ke basis data Git. Adalah sulit untuk membuat sistem melakukan apapun yang tidak dapat dikembalikan atau membuatnya menghapus data dalam berbagai cara. Seperti pada VCS lain, Anda dapat kehilangan atau mengacak-acak perubahan yang belum Anda commit ; namun, setelah Anda melakukan commit snapshot ke Git, akan sangat sulit untuk kehilangan, terutama jika Anda menyimpan ke basis data Anda ke repository lain secara rutin. Ini membuat menggunakan Git adalah sebuah kebahagiaan, karena kita tahu kita dapat melakukan uji coba tanpa bahaya dari mengacak-acak hal-hal. Untuk melihat lebih dalam tentang bagaimana Git menyimpan datanya dan bagaimana Anda dapat memulihkan data yang kelihatannya hilang, lihat Tiga Keadaan \u00b6 Sekarang, perhatikan. Ini adalah hal utama untuk diingat tentang Git jika Anda ingin sisa perjalanan belajar Anda berjalan dengan lancar. Git memiliki tiga keadaan utama yang berkas-berkas Anda dapat masuk ke dalamnya: committed , modified , dan staged . - Commited berarti datanya telah tersimpan dengan aman pada basis data lokal Anda. - Modified berarti Anda telah mengubah berkas, namun belum di- commit ke basis data Anda. - Staged berarti Anda telah menandai berkas yang telah diubah ke dalam versi sekarang untuk snapshot commit Anda selanjutnya. Ini memimpin kita kepada tiga bab utama dalam proyek Git: direktori Git, working directory , dan staging area . sequenceDiagram Direktori Kerja-->Staging Area: note over Repository: .git folder/directory Repository-)Direktori Kerja: Checkout Note over Repository,Direktori Kerja: mengubah berkas dalam working directory Anda. Direktori Kerja-)Staging Area: Stage files Note over Direktori Kerja,Staging Area: menyiapkan berkasnya. Staging Area-)Repository: Commit Note over Repository,Staging Area: mengambil berkas-berkas Directory Git adalah di mana Git menyimpan metadata dan basis data obyek untuk proyek Anda. Ini adalah bagian paling penting tentang Git, dan ini adalah apa yang disalin ketika Anda menggandakan sebuah repository dari komputer lain. Working directory adalah sebuah checkout tunggal dari satu versi milik proyek. Berkas-berkas ini ditarik dari basis data yang telah dimampatkan dalam direktori Git dan ditempatkan pada diska untuk Anda gunakan atau sunting. Staging area adalah sebuah berkas, umumnya berada pada direktori Git Anda, yang menyimpan informasi tentang apa yang akan menjadi commit Anda selanjutnya. Terkadang disebut juga sebagai index, namun juga sering disebut sebagai staging area . Alur kerja dasar Git adalah seperti berikut: Anda mengubah berkas dalam working directory Anda. Anda menyiapkan berkasnya, menambah snapshot darinya ke staging area Anda. Anda melakukan commit , yang mengambil berkas-berkas yang ada pada staging area dan menyimpan snapshot tersebut secara tetap ke dalam direktori Git Anda. Jika sebuah versi tertentu dari sebuah berkas ada pada direktori Git, itu dianggap telah committed . Jika itu diubah, namun telah ditambahkan ke staging area , maka itu staged . Dan jika itu telah diubah sejak setelah di- check out , namun belum staged , maka itu adalah modified . Dalam [bab_dasar-dasar_git], Anda akan belajar lebih banyak tentang keadaan tersebut dan bagaimana Anda dapat memanfaatkannya atau melewati semua ke bagian staged .","title":"Dasar-dasar Git"},{"location":"belajar/git/dasar-git/#dasar-dasar-git","text":"Jadi, mudahnya, apakah Git itu? Ini adalah bab yang penting untuk dipahami, karena jika Anda memahami apa itu Git dan pemahaman dasar tentang bagaimana Git bekerja, maka, menggunakan Git dengan efektif mungkin akan menjadi lebih mudah Anda lakukan. Selama Anda belajar Git, cobalah untuk menjernihkan pikiran Anda dari hal-hal yang Anda ketahui tentang VCS lainnya, seperti Subversion dan Perforce; dengan begitu, akan membantu Anda menghindari hal-hal yang membingungkan ketika menggunakan alatnya. Git menyimpan dan berpikir tentang informasi dengan sangat berbeda daripada sistem lainnya, meskipun antarmuka penggunanya cukup mirip, dan memahami perbedaan-perbedaan tersebut akan membantu mencegah Anda menjadi bingung ketika menggunakannya.","title":"Dasar-dasar Git"},{"location":"belajar/git/dasar-git/#snapshots-bukan-perbedaan-perbedaan","text":"Perbedaan besar antara Git dan VCS lainnya (Subversion dan sejenisnya) adalah tentang cara Git berpikir tentang datanya. Secara konsep, kebanyakan sistem lain menyimpan informasi sebagai sebuah daftar dari perubahan-perubahan berbasis berkas. Sistem-sistem tersebut (CVS, Subversion, Perforce, Bazaar, dan seterusnya) berpikir tentang informasi yang mereka simpan sebagai sekumpulan berkas dan perubahan-perubahan yang dibuat kepada tiap berkas sepanjang waktu. graph LR A(Versi 1) --- A1(Versi 2) --- A2(Versi 3) --- A3(Versi 4) --- A4(Versi 5) B(File A) --> B1(#1) ---> B2(#2) C(File B) ----> C1(#1) --> C2(#2) D(File C) --> D1(#1) --> D2(#2) ---> D3(#3) Git tidak berpikir atau menyimpan datanya dengan cara ini. Namun, Git berpikir tentang datanya lebih seperti sekumpulan snapshot dari sebuah miniatur filesystem . Setiap kali Anda melakukan commit , atau menyimpan keadaan dari proyek Anda di Git, pada dasarnya itu mengambil sebuah gambar tentang bagaimana tampilan semua berkas Anda pada saat itu dan menyimpan acuan kepada snapshot tersebut. Singkatnya, jika berkas-berkas itu tidak berubah, Git tidak menyimpan berkasnya lagi, hanya menautkan ke berkas yang sama persis sebelumnya yang telah tersimpan. Git berpikir tentang datanya lebih seperti sebuah aliran snapshot . graph TD A(Versi 1) --- A1(File A) --- A2(File B) --- A3(File C) B(Versi 2) --- B1(A1) --- B2(B) --- B3(C1) C(Versi 3) --- C1(A1) --- C2(B) --- C3(C2) D(Versi 4) --- D1(A2) --- D2(B1) --- D3(C2) E(Versi 5) --- E1(A2) --- E2(B2) --- E3(C3) style B2 stroke-width:2px,stroke-dasharray: 5 5 style C1 stroke-width:2px,stroke-dasharray: 5 5 style C2 stroke-width:2px,stroke-dasharray: 5 5 style D3 stroke-width:2px,stroke-dasharray: 5 5 style E1 stroke-width:2px,stroke-dasharray: 5 5 Ini adalah perbedaan penting antara Git dan hampir semua VCS lainnya. Hal itu membuat Git mempertimbangkan ulang hampir semua aspek dari version control yang kebanyakan sistem lainnya tiru dari generasi sebelumnya. Ini membuat Git lebih seperti sebuah filesystem kecil dengan beberapa alat yang sangat hebat terpasang padanya, daripada hanya sebuah VCS sederhana. Kita akan menjelajahi beberapa keuntungan yang Anda dapatkan dengan berpikir tentang data Anda seperti ini ketika kami membahas percabangan Git pada Git Branching.","title":"Snapshots, Bukan Perbedaan-perbedaan"},{"location":"belajar/git/dasar-git/#hampir-setiap-pekerjaan-adalah-lokal","text":"Kebanyakan pekerjaan pada Git hanya membutuhkan berkas-berkas dan sumber daya lokal untuk bekerja \u2013 secara umum, tidak ada informasi yang dibutuhkan dari komputer lain dalam jaringan Anda. Jika Anda terbiasa dengan CVCS di mana kebanyakan pekerjaan memiliki kelebihan network latency , aspek ini dalam Git akan membuat Anda berpikir bahwa Tuhan telah memberkati Git dengan kekuatan yang tak dapat diungkapkan dengan kata-kata. Karena, jika Anda memiliki seluruh riwayat proyek tepat berada di dalam local disk Anda, kebanyakan pekerjaan terlihat hampir dalam sekejap. Sebagai contoh, untuk meramban riwayat dari proyek, Git tidak perlu pergi ke server untuk mendapatkan riwayat dan menampilkannya kepada Anda \u2013 dia hanya membacanya langsung dari basis data lokal Anda. Ini berarti Anda melihat riwayat proyek hampir dalam sekejap. Jika Anda ingin melihat perubahan-perubahan yang dikenalkan antara versi sekarang dari sebuah berkas dan berkasnya pada saat sebulan yang lalu, Git dapat mencari berkasnya sebulan yang lalu dan melakukan perhitungan perbedaan secara lokal, bukannya meminta kepada remote server untuk melakukannya atau menarik versi lama dari berkas dari remote server untuk melakukannya secara lokal. Ini juga berarti bahwa hanya ada sedikit hal yang tidak dapat Anda lakukan ketika Anda berada di luar jaringan atau di luar VPN. Jika Anda sedang mengendarai pesawat terbang atau kereta dan ingin sedikit bekerja, Anda dapat melakukan commit dengan bahagia hingga Anda mendapat sambungan jaringan untuk mengunggah. Jika Anda pulang dan tidak dapat menggunakan klien VPN dengan wajar, Anda masih dapat bekerja. Pada banyak sistem lain, melakukan hal tersebut adalah tidak mungkin atau sangat susah. Pada Perforce, misalnya, Anda tidak dapat melakukan banyak hal ketika Anda tidak tersambung ke server ; dan pada Subversion dan CVS, Anda dapat menyunting berkas, namun Anda tidak dapat melakukan commit tentang perubahan-perubahan ke basis data Anda (karena basis data Anda sedang luring). Ini mungkin tidak terlihat seperti sebuah masalah, namun, Anda mungkin akan terkejut betapa besar perbedaan yang dapat dibuatnya.","title":"Hampir Setiap Pekerjaan Adalah Lokal"},{"location":"belajar/git/dasar-git/#git-memiliki-integritas","text":"Semuanya dalam Git telah dilakukan checksum sebelum itu disimpan dan kemudian mengacu pada checksum tersebut. Ini berarti bahwa tidak mungkin untuk mengubah isi dari sebarang berkas atau direktori tanpa diketahui oleh Git. Kemampuan ini terpasang pada Git pada tingkat paling bawah dan terpadu pada filosofinya. Anda tidak dapat kehilangan informasi dalam singgahan atau mendapat berkas yang corrupt yang tidak terlacak oleh Git. Cara kerja yang digunakan oleh Git untuk melakukan checksum disebut dengan SHA-1 hash . Ini adalah kumpulan kata sepanjang 40 karakter dari karakter heksadesimal (0-9 dan a-f) dan dihitung berdasarkan isi dari sebuah berkas atau struktur direktori dalam Git. Sebuah SHA-1 hash nampak seperti berikut: Contoh hash 24b9da6552252987aa493b52f8696cd6d3b00373 Anda akan melihat nilai hash tersebut di semua tempat pada Git karena dia sering menggunakannya. Nyatanya, Git menyimpan semuanya dalam basis datanya bukan dari nama berkas, namun dari nilai hash isinya.","title":"Git Memiliki Integritas"},{"location":"belajar/git/dasar-git/#git-umumnya-hanya-menambah-data","text":"Ketika Anda melakukan aksi dalam Git, hampir semuanya hanya menambahkan data ke basis data Git. Adalah sulit untuk membuat sistem melakukan apapun yang tidak dapat dikembalikan atau membuatnya menghapus data dalam berbagai cara. Seperti pada VCS lain, Anda dapat kehilangan atau mengacak-acak perubahan yang belum Anda commit ; namun, setelah Anda melakukan commit snapshot ke Git, akan sangat sulit untuk kehilangan, terutama jika Anda menyimpan ke basis data Anda ke repository lain secara rutin. Ini membuat menggunakan Git adalah sebuah kebahagiaan, karena kita tahu kita dapat melakukan uji coba tanpa bahaya dari mengacak-acak hal-hal. Untuk melihat lebih dalam tentang bagaimana Git menyimpan datanya dan bagaimana Anda dapat memulihkan data yang kelihatannya hilang, lihat","title":"Git Umumnya Hanya Menambah Data"},{"location":"belajar/git/dasar-git/#tiga-keadaan","text":"Sekarang, perhatikan. Ini adalah hal utama untuk diingat tentang Git jika Anda ingin sisa perjalanan belajar Anda berjalan dengan lancar. Git memiliki tiga keadaan utama yang berkas-berkas Anda dapat masuk ke dalamnya: committed , modified , dan staged . - Commited berarti datanya telah tersimpan dengan aman pada basis data lokal Anda. - Modified berarti Anda telah mengubah berkas, namun belum di- commit ke basis data Anda. - Staged berarti Anda telah menandai berkas yang telah diubah ke dalam versi sekarang untuk snapshot commit Anda selanjutnya. Ini memimpin kita kepada tiga bab utama dalam proyek Git: direktori Git, working directory , dan staging area . sequenceDiagram Direktori Kerja-->Staging Area: note over Repository: .git folder/directory Repository-)Direktori Kerja: Checkout Note over Repository,Direktori Kerja: mengubah berkas dalam working directory Anda. Direktori Kerja-)Staging Area: Stage files Note over Direktori Kerja,Staging Area: menyiapkan berkasnya. Staging Area-)Repository: Commit Note over Repository,Staging Area: mengambil berkas-berkas Directory Git adalah di mana Git menyimpan metadata dan basis data obyek untuk proyek Anda. Ini adalah bagian paling penting tentang Git, dan ini adalah apa yang disalin ketika Anda menggandakan sebuah repository dari komputer lain. Working directory adalah sebuah checkout tunggal dari satu versi milik proyek. Berkas-berkas ini ditarik dari basis data yang telah dimampatkan dalam direktori Git dan ditempatkan pada diska untuk Anda gunakan atau sunting. Staging area adalah sebuah berkas, umumnya berada pada direktori Git Anda, yang menyimpan informasi tentang apa yang akan menjadi commit Anda selanjutnya. Terkadang disebut juga sebagai index, namun juga sering disebut sebagai staging area . Alur kerja dasar Git adalah seperti berikut: Anda mengubah berkas dalam working directory Anda. Anda menyiapkan berkasnya, menambah snapshot darinya ke staging area Anda. Anda melakukan commit , yang mengambil berkas-berkas yang ada pada staging area dan menyimpan snapshot tersebut secara tetap ke dalam direktori Git Anda. Jika sebuah versi tertentu dari sebuah berkas ada pada direktori Git, itu dianggap telah committed . Jika itu diubah, namun telah ditambahkan ke staging area , maka itu staged . Dan jika itu telah diubah sejak setelah di- check out , namun belum staged , maka itu adalah modified . Dalam [bab_dasar-dasar_git], Anda akan belajar lebih banyak tentang keadaan tersebut dan bagaimana Anda dapat memanfaatkannya atau melewati semua ke bagian staged .","title":"Tiga Keadaan"},{"location":"belajar/git/install-git/","text":"Install Git \u00b6 Sebelum Anda mulai menggunakan Git, Anda harus membuatnya tersedia pada komputer Anda. Meskipun sudah terpasang, adalah gagasan yang baik untuk memperbarui ke versi terakhir. Anda dapat memasangnya sebagai package atau melalui pemasang lainnya, atau mengunduh sumber kodenya dan meng- compile -nya sendiri. Note Buku ini ditulis menggunakan Git versi 2.0.0 . Meski begitu, kebanyakan perintah yang kita gunakan seharusnya dapat bekerja meskipun pada versi Git yang sebelumnya, beberapa dari itu mungkin tidak bekerja atau bekerja dengan sedikit berbeda jika Anda menggunakan versi yang sebelumnya. Karena Git sangat baik dalam mempertahankan kesesuaian dengan versi sebelumnya, sebarang versi setelah 2.0 seharusnya dapat bekerja dengan baik. Install Di linux \u00b6 Hal ini paling mudah untuk menginstal Git di Linux menggunakan pilihan paket manajer distribusi Linux anda. Jika anda lebih memilih untuk membangun dari sumber, anda dapat menemukan tarball di kernel.org. Versi terbaru adalah 2.37.3 . Debian/Ubuntu Fedora Gentoo Arch Linux openSUSE Mageia Nix/NixOS FreeBSD Solaris 9/10/11 (OpenCSW) Solaris 11 Express OpenBSD Alpine Slitaz Red Hat Enterprise Linux, Oracle Linux, CentOS, Scientific Linux, dll. Untuk versi stabil terbaru untuk rilis Debian/Ubuntu apt-get install git Untuk Ubuntu, PPA ini menyediakan versi stabil terbaru dari upstream Git add-apt-repository ppa:git-core/ppa # apt update; apt install git yum install git (up to Fedora 21) dnf install git (Fedora 22 and later) emerge --ask --verbose dev-vcs/git pacman -S git zypper install git urpmi git nix-env -i git pkg install git pkgutil -i git pkg install developer/versioning/git pkg_add git apk add git tazpkg add git RHEL dan turunannya biasanya menggunakan paket versi git. Anda dapat men-download tarball dan membangun dari sumber, atau gunakan pihak ke-3 repositori seperti IUS Proyek Komunitas untuk mendapatkan versi yang lebih baru dari git Install di Mac \u00b6 Ada beberapa opsi untuk menginstal Git di macOS. Perhatikan bahwa setiap distribusi non-sumber disediakan oleh pihak ketiga, dan dapat tidak up to date dengan rilis sumber terbaru. Homebrew MacPorts XCode Install Binary Membangun dari sumber Install git-gui Install homebrew Jika belum memilikinya, lalu: brew install git Install MacPorts jika belum memilikinya, lalu: sudo port install git Apple membuat paket biner Git dengan Xcode . Tim Harper menyediakan skript instalasi untuk Git. Versi terbaru adalah 2.33.0 , yang dirilis sekitar 1 tahun yang lalu, pada 2021-08-30. Jika Anda lebih suka membangun dari sumber, Anda dapat menemukan tarball di kernel.org . Versi terbaru adalah 2.37.3 . Jika Anda ingin menginstal git-gui dan gitk , git's commit GUI dan browser riwayat interaktif, Anda dapat melakukannya menggunakan homebrew brew install git-gui Anda juga dapat memasangnya sebagai bagian dari pemasangan GitHub untuk Mac. GUI untuk Git mereka memiliki pilihan untuk memasang peralatan command line juga. Anda dapat mengunduh alatnya dari situs web GitHub untuk Mac, pada http://mac.github.com . Installl di Windows \u00b6 Juga ada beberapa cara untuk memasang Git pada Windows. Bentuk resminya dapat diunduh pada situs web Git. Pergi ke http://git-scm.com/download/win dan unduhannya akan berjalan secara otomatis. Catat bahwa ini adalah proyek yang bernama Git untuk Windows (juga disebut dengan msysGit), yang terpisah dari Git itu sendiri; untuk informasi lebih lanjut, pergi ke http://msysgit.github.io/ . Cara mudah lainnya untuk memasang Git adalah dengan memasang GitHub untuk Windows. Pemasangnya menyertakan versi command line dari Git dan juga GUI-nya. Itu juga bekerja dengan baik pada Powershell, dan mengatur credential caching dengan solid dan pengaturan sane CRLF . Kita akan belajar lebih tentang hal-hal tersebut sebentar lagi, namun bisa dikatakan ini adalah yang Anda inginkan. Anda dapat mengunduh ini dari situs web GitHub untuk Windows, pada http://windows.github.com . Install dari sumber \u00b6 Beberapa orang mungkin merasa memasang Git dari sumbernya adalah hal yang berguna, karena Anda akan mendapatkan versi yang paling mutakhir. Pemasang biner cenderung tertinggal, meski Git telah berkembang dalam beberapa tahun terakhir, hal ini tidak membuat perbedaan yang berarti. Jika Anda ingin memasang Git dari sumbernya, Anda perlu memiliki library berikut yang Git bergantung padanya: curl , zlib , openssl , expat , dan libiconv . Sebagai contoh, jika Anda berada pada sistem yang memiliki yum (seperti Fedora) atau apt-get (seperti pada sistem berdasarkan Debian), Anda dapat menggunakan salah satu dari perintah-perintah berikut untuk memasang semua kebutuhannya: Fedora Debian/Ubuntu yum install curl-devel expat-devel gettext-devel \\ openssl-devel zlib-devel apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \\ libz-dev libssl-dev Ketika Anda telah memiliki semua yang dibutuhkan, Anda dapat pergi dan mengambil keluaran tarball terbaru dari beberapa tempat. Anda dapat mengambilnya lewat situs Kernel.org, pada https://www.kernel.org/pub/software/scm/git , atau dari mirror milik situs GitHub, pada https://github.com/git/git/releases . Pada umumnya nampak jelas versi apa yang paling mutakhir pada halaman GitHub, namun pada halaman kernel.org juga memiliki release signature jika Anda ingin memeriksa unduhan Anda. Kemudian, compile dan pasang: 1 2 3 4 5 6 tar -zxf git-1.9.1.tar.gz cd git-1.9.1 make configure ./configure --prefix = /usr make all doc info sudo make install install-doc install-html install-info Setelah ini selesai, Anda juca dapat mengambil Git lewat Git itu sendiri untuk pembaruan: git clone git://git.kernel.org/pub/scm/git/git.git","title":"Instalasi Git"},{"location":"belajar/git/install-git/#install-git","text":"Sebelum Anda mulai menggunakan Git, Anda harus membuatnya tersedia pada komputer Anda. Meskipun sudah terpasang, adalah gagasan yang baik untuk memperbarui ke versi terakhir. Anda dapat memasangnya sebagai package atau melalui pemasang lainnya, atau mengunduh sumber kodenya dan meng- compile -nya sendiri. Note Buku ini ditulis menggunakan Git versi 2.0.0 . Meski begitu, kebanyakan perintah yang kita gunakan seharusnya dapat bekerja meskipun pada versi Git yang sebelumnya, beberapa dari itu mungkin tidak bekerja atau bekerja dengan sedikit berbeda jika Anda menggunakan versi yang sebelumnya. Karena Git sangat baik dalam mempertahankan kesesuaian dengan versi sebelumnya, sebarang versi setelah 2.0 seharusnya dapat bekerja dengan baik.","title":"Install Git"},{"location":"belajar/git/install-git/#install-di-linux","text":"Hal ini paling mudah untuk menginstal Git di Linux menggunakan pilihan paket manajer distribusi Linux anda. Jika anda lebih memilih untuk membangun dari sumber, anda dapat menemukan tarball di kernel.org. Versi terbaru adalah 2.37.3 . Debian/Ubuntu Fedora Gentoo Arch Linux openSUSE Mageia Nix/NixOS FreeBSD Solaris 9/10/11 (OpenCSW) Solaris 11 Express OpenBSD Alpine Slitaz Red Hat Enterprise Linux, Oracle Linux, CentOS, Scientific Linux, dll. Untuk versi stabil terbaru untuk rilis Debian/Ubuntu apt-get install git Untuk Ubuntu, PPA ini menyediakan versi stabil terbaru dari upstream Git add-apt-repository ppa:git-core/ppa # apt update; apt install git yum install git (up to Fedora 21) dnf install git (Fedora 22 and later) emerge --ask --verbose dev-vcs/git pacman -S git zypper install git urpmi git nix-env -i git pkg install git pkgutil -i git pkg install developer/versioning/git pkg_add git apk add git tazpkg add git RHEL dan turunannya biasanya menggunakan paket versi git. Anda dapat men-download tarball dan membangun dari sumber, atau gunakan pihak ke-3 repositori seperti IUS Proyek Komunitas untuk mendapatkan versi yang lebih baru dari git","title":"Install Di linux"},{"location":"belajar/git/install-git/#install-di-mac","text":"Ada beberapa opsi untuk menginstal Git di macOS. Perhatikan bahwa setiap distribusi non-sumber disediakan oleh pihak ketiga, dan dapat tidak up to date dengan rilis sumber terbaru. Homebrew MacPorts XCode Install Binary Membangun dari sumber Install git-gui Install homebrew Jika belum memilikinya, lalu: brew install git Install MacPorts jika belum memilikinya, lalu: sudo port install git Apple membuat paket biner Git dengan Xcode . Tim Harper menyediakan skript instalasi untuk Git. Versi terbaru adalah 2.33.0 , yang dirilis sekitar 1 tahun yang lalu, pada 2021-08-30. Jika Anda lebih suka membangun dari sumber, Anda dapat menemukan tarball di kernel.org . Versi terbaru adalah 2.37.3 . Jika Anda ingin menginstal git-gui dan gitk , git's commit GUI dan browser riwayat interaktif, Anda dapat melakukannya menggunakan homebrew brew install git-gui Anda juga dapat memasangnya sebagai bagian dari pemasangan GitHub untuk Mac. GUI untuk Git mereka memiliki pilihan untuk memasang peralatan command line juga. Anda dapat mengunduh alatnya dari situs web GitHub untuk Mac, pada http://mac.github.com .","title":"Install di Mac"},{"location":"belajar/git/install-git/#installl-di-windows","text":"Juga ada beberapa cara untuk memasang Git pada Windows. Bentuk resminya dapat diunduh pada situs web Git. Pergi ke http://git-scm.com/download/win dan unduhannya akan berjalan secara otomatis. Catat bahwa ini adalah proyek yang bernama Git untuk Windows (juga disebut dengan msysGit), yang terpisah dari Git itu sendiri; untuk informasi lebih lanjut, pergi ke http://msysgit.github.io/ . Cara mudah lainnya untuk memasang Git adalah dengan memasang GitHub untuk Windows. Pemasangnya menyertakan versi command line dari Git dan juga GUI-nya. Itu juga bekerja dengan baik pada Powershell, dan mengatur credential caching dengan solid dan pengaturan sane CRLF . Kita akan belajar lebih tentang hal-hal tersebut sebentar lagi, namun bisa dikatakan ini adalah yang Anda inginkan. Anda dapat mengunduh ini dari situs web GitHub untuk Windows, pada http://windows.github.com .","title":"Installl di Windows"},{"location":"belajar/git/install-git/#install-dari-sumber","text":"Beberapa orang mungkin merasa memasang Git dari sumbernya adalah hal yang berguna, karena Anda akan mendapatkan versi yang paling mutakhir. Pemasang biner cenderung tertinggal, meski Git telah berkembang dalam beberapa tahun terakhir, hal ini tidak membuat perbedaan yang berarti. Jika Anda ingin memasang Git dari sumbernya, Anda perlu memiliki library berikut yang Git bergantung padanya: curl , zlib , openssl , expat , dan libiconv . Sebagai contoh, jika Anda berada pada sistem yang memiliki yum (seperti Fedora) atau apt-get (seperti pada sistem berdasarkan Debian), Anda dapat menggunakan salah satu dari perintah-perintah berikut untuk memasang semua kebutuhannya: Fedora Debian/Ubuntu yum install curl-devel expat-devel gettext-devel \\ openssl-devel zlib-devel apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \\ libz-dev libssl-dev Ketika Anda telah memiliki semua yang dibutuhkan, Anda dapat pergi dan mengambil keluaran tarball terbaru dari beberapa tempat. Anda dapat mengambilnya lewat situs Kernel.org, pada https://www.kernel.org/pub/software/scm/git , atau dari mirror milik situs GitHub, pada https://github.com/git/git/releases . Pada umumnya nampak jelas versi apa yang paling mutakhir pada halaman GitHub, namun pada halaman kernel.org juga memiliki release signature jika Anda ingin memeriksa unduhan Anda. Kemudian, compile dan pasang: 1 2 3 4 5 6 tar -zxf git-1.9.1.tar.gz cd git-1.9.1 make configure ./configure --prefix = /usr make all doc info sudo make install install-doc install-html install-info Setelah ini selesai, Anda juca dapat mengambil Git lewat Git itu sendiri untuk pembaruan: git clone git://git.kernel.org/pub/scm/git/git.git","title":"Install dari sumber"},{"location":"belajar/git/kesimpulan/","text":"Seharusnya Anda telah memiliki pemahaman dasar tentang apa itu Git dan bagaimana Git berbeda dari sistem version control yang terpusat yang mungkin telah Anda gunakan sebelumnya. Sekarang, seharusnya Anda juga telah memiliki sebuah versi dari Git yang mampu bekerja pada sistem Anda yang telah diatur dengan identitas pribadi Anda. Sekarang saatnya untuk belajar beberapa dasar dari Git.","title":"Kesimpulan"},{"location":"belajar/git/mengatur-git/","text":"Karena sekarang Anda telah memiliki Git pada sistem Anda, Anda mungkin ingin melakukan beberapa hal untuk mengatur lingkungan Git Anda. Sebaiknya Anda melakukan hal ini sekali pada setiap komputer yang diberikan; hal-hal ini akan tetap ada pada setiap peningkatan. Anda juga dapat mengubah pengaturan tersebut setiap saat dengan menjalankan kembali perintah-perintah tersebut. Git datang dengan sebuah alat bernama git config yang membolehkan Anda mendapatkan dan mengatur variabel-variabel pengaturan yang mengatur semua aspek tentang bagaimana Git tampak dan bekerja. Variabel-variabel tersebut dapat disimpan pada tiga tempat yang berbeda: Berkas /etc/gitconfig : Berisi nilai-nilai untuk setiap pengguna pada sistem dan semua repository mereka. Jika Anda memberikan pilihan --system kepada git config , dia membaca dan menulis dari berkas ini secara khusus. Berkas ~/.gitconfig atau ~/.config/git/config : Khusus untuk pengguna Anda. Anda dapat membuat Git membaca dan menulis ke berkas ini secara khusus dengan memberikan pilihan --global . Berkas config dalam direktori Git (yaitu, .git/config ) atau sebarang repository yang sedang Anda gunakan: Khusus untuk repository tunggal tersebut. Setiap tingkat menimpa nilai pada tingkat sebelumnya, jadi, nilai-nilai pada .git/config menimpa yang ada pada /etc/gitconfig . Pada sistem Windows, Git mencari berkas .gitconfig pada direktori $HOME ( C:\\Users\\$USER untuk kebanyakan orang). Git juga tetap mencari /etc/gitconfig , meskipun terhubung kepada MSys root , yang mana di manapun Anda memilih untuk memasang Git pada sistem Windows Anda ketika Anda menjalankan pemasang Git. Identitas \u00b6 Hal pertama yang sebaiknya Anda lakukan ketika memasang Git adalah menetapkan nama pengguna dan alamat surel. Ini penting, karena setiap commit pada Git menggunakan informasi ini, dan itu dituliskan dan tidak dapat diganti ke dalam commit yang Anda buat: Konfigurasi Nama git config --global user.name \"John Doe\" Konfigurasi Email git config --global user.email johndoe@example.com Sekali lagi, Anda hanya perlu melakukan ini sekali saja jika Anda memberikan pilihan --global , karena Git akan selalu menggunakan informasi tersebut untuk apapun yang Anda lakukan pada sistem tersebut. Jika Anda ingin menimpa ini dengan nama atau alamat surel yang berbeda untuk proyek tertentu, Anda dapat menjalankan perintah tanpa pilihan --global ketika Anda berada pada proyek tersebut. Banyak dari peralatan GUI akan membantu Anda melakukan hal ini ketika Anda menjalankannya pertama kali. Editor \u00b6 Sekarang, identitas Anda telah siap, Anda dapat mengatur editor teks bawaan yang akan digunakan ketika Git memerlukan Anda untuk menuliskan pesan/ Jika tidak diatur, Git menggunakan editor teks bawaan pada sistem Anda, yang pada umumnya adalah Vim. Jika Anda ingin menggunakan editor teks yang berbeda, seperti Emacs, Anda dapat melakukan hal berikut: git config --global core.editor emacs Note Vim dan Emacs adalah editor teks terkenal yang sering digunakan oleh para pengembang pada sistem berdasarkan Unix seperti Linux dan Mac. Jika Anda tidak terbiasa dengan kedua editor tersebut atau berada pada sistem Windows, Anda mungkin perlu mencari arahan tentang bagaimana cara mengatur editor kesukaan Anda dengan Git. Jika Anda tidak menetapkan editor seperti ini dan Anda tidak tahu apa itu Vim atau Emacs, Anda akan mendapatkan hal yang membingungkan ketika mereka diluncurkan. Cek Pengaturan \u00b6 Jika Anda ingin memeriksa pengaturan Anda, Anda dapat menggunakan perintah git config --list untuk mendaftar semua pengaturan yang dapat ditemukan Git pada saat itu: git config --list user.name = John Doe user.email = johndoe@example.com color.status = auto color.branch = auto color.interactive = auto color.diff = auto ... Anda mungkin melihat kunci-kunci lebih dari satu, karena Git membaca kunci yang sama dari berkas-berkas yang berbeda ( /etc/gitconfig dan ~/.gitconfig , contohnya). Dalam hal ini, Git menggunakan nilai terakhit dari setiap kunci unik yang dia lihat. Anda juga dapat memeriksa apa yang Git pikirkan dalam nilai kunci khusus dengan mengetikkan git config <key> : git config user.name Jhon Doe","title":"Pengaturan Awal Git"},{"location":"belajar/git/mengatur-git/#identitas","text":"Hal pertama yang sebaiknya Anda lakukan ketika memasang Git adalah menetapkan nama pengguna dan alamat surel. Ini penting, karena setiap commit pada Git menggunakan informasi ini, dan itu dituliskan dan tidak dapat diganti ke dalam commit yang Anda buat: Konfigurasi Nama git config --global user.name \"John Doe\" Konfigurasi Email git config --global user.email johndoe@example.com Sekali lagi, Anda hanya perlu melakukan ini sekali saja jika Anda memberikan pilihan --global , karena Git akan selalu menggunakan informasi tersebut untuk apapun yang Anda lakukan pada sistem tersebut. Jika Anda ingin menimpa ini dengan nama atau alamat surel yang berbeda untuk proyek tertentu, Anda dapat menjalankan perintah tanpa pilihan --global ketika Anda berada pada proyek tersebut. Banyak dari peralatan GUI akan membantu Anda melakukan hal ini ketika Anda menjalankannya pertama kali.","title":"Identitas"},{"location":"belajar/git/mengatur-git/#editor","text":"Sekarang, identitas Anda telah siap, Anda dapat mengatur editor teks bawaan yang akan digunakan ketika Git memerlukan Anda untuk menuliskan pesan/ Jika tidak diatur, Git menggunakan editor teks bawaan pada sistem Anda, yang pada umumnya adalah Vim. Jika Anda ingin menggunakan editor teks yang berbeda, seperti Emacs, Anda dapat melakukan hal berikut: git config --global core.editor emacs Note Vim dan Emacs adalah editor teks terkenal yang sering digunakan oleh para pengembang pada sistem berdasarkan Unix seperti Linux dan Mac. Jika Anda tidak terbiasa dengan kedua editor tersebut atau berada pada sistem Windows, Anda mungkin perlu mencari arahan tentang bagaimana cara mengatur editor kesukaan Anda dengan Git. Jika Anda tidak menetapkan editor seperti ini dan Anda tidak tahu apa itu Vim atau Emacs, Anda akan mendapatkan hal yang membingungkan ketika mereka diluncurkan.","title":"Editor"},{"location":"belajar/git/mengatur-git/#cek-pengaturan","text":"Jika Anda ingin memeriksa pengaturan Anda, Anda dapat menggunakan perintah git config --list untuk mendaftar semua pengaturan yang dapat ditemukan Git pada saat itu: git config --list user.name = John Doe user.email = johndoe@example.com color.status = auto color.branch = auto color.interactive = auto color.diff = auto ... Anda mungkin melihat kunci-kunci lebih dari satu, karena Git membaca kunci yang sama dari berkas-berkas yang berbeda ( /etc/gitconfig dan ~/.gitconfig , contohnya). Dalam hal ini, Git menggunakan nilai terakhit dari setiap kunci unik yang dia lihat. Anda juga dapat memeriksa apa yang Git pikirkan dalam nilai kunci khusus dengan mengetikkan git config <key> : git config user.name Jhon Doe","title":"Cek Pengaturan"},{"location":"belajar/git/sejarah-singkat/","text":"1.2 Sejarah Singkat Git \u00b6 Bersamaan dengan banyak hal besar dalam hidup, Git dimulai dengan sedikit kehancuran kreatifitas dan pertentangan yang ganas. Kernel Linux adalah proyek perangkat lunak sumber terbuka dalam lingkup yang cukup besar. Sebagian besar waktu pemeliharaan dari kernel Linux (1991-2002), perubahan-perubahan pada perangkat lunak diberikan sebagai patch dan berkas terarsipkan. Pada 2002, proyek kernel Linux mulai menggunakan DVCS terpatenkan bernama BitKeeper. Pada 2005, hubungan antara komunitas yang mengembangkan kernel Linux dan perusahaan komersil yang mengembangkan BitKeeper terputus, dan status bebas biaya dari alatnya dicabut. Hal ini mendesak komunitas pengembangan Linux (khususnya Linus Torvalds, pencipta Linux) untuk mengembangkan alat mereka sendiri berdasarkan beberapa pelajaran yang telah mereka pelajari ketika menggunakan BitKeeper. Beberapa sasaran dari sistem baru tersebut adalah sebagai berikut: Kecepatan Rancangan yang sederhana Dukungan yang kuat untuk pengembangan non-linier (ribuan cabang paralel) Benar-benar tersebar Mampu menangani proyek besar seperti Linux secara efisien (kecepatan dan ukuran data) Sejak kelahirannya pada 2005, Git telah berevolusi dan berkembang untuk dapat digunakan dengan mudah namun tetap memiliki kualitas awal tersebut. Git sangat cepat, sangat efisien dengan proyek-proyek besar, dan Git memiliki sistem percabangan yang hebat untuk pengembangan non-linear.","title":"Sejarah Singkat"},{"location":"belajar/git/sejarah-singkat/#12-sejarah-singkat-git","text":"Bersamaan dengan banyak hal besar dalam hidup, Git dimulai dengan sedikit kehancuran kreatifitas dan pertentangan yang ganas. Kernel Linux adalah proyek perangkat lunak sumber terbuka dalam lingkup yang cukup besar. Sebagian besar waktu pemeliharaan dari kernel Linux (1991-2002), perubahan-perubahan pada perangkat lunak diberikan sebagai patch dan berkas terarsipkan. Pada 2002, proyek kernel Linux mulai menggunakan DVCS terpatenkan bernama BitKeeper. Pada 2005, hubungan antara komunitas yang mengembangkan kernel Linux dan perusahaan komersil yang mengembangkan BitKeeper terputus, dan status bebas biaya dari alatnya dicabut. Hal ini mendesak komunitas pengembangan Linux (khususnya Linus Torvalds, pencipta Linux) untuk mengembangkan alat mereka sendiri berdasarkan beberapa pelajaran yang telah mereka pelajari ketika menggunakan BitKeeper. Beberapa sasaran dari sistem baru tersebut adalah sebagai berikut: Kecepatan Rancangan yang sederhana Dukungan yang kuat untuk pengembangan non-linier (ribuan cabang paralel) Benar-benar tersebar Mampu menangani proyek besar seperti Linux secara efisien (kecepatan dan ukuran data) Sejak kelahirannya pada 2005, Git telah berevolusi dan berkembang untuk dapat digunakan dengan mudah namun tetap memiliki kualitas awal tersebut. Git sangat cepat, sangat efisien dengan proyek-proyek besar, dan Git memiliki sistem percabangan yang hebat untuk pengembangan non-linear.","title":"1.2 Sejarah Singkat Git"},{"location":"belajar/git/version-control/","text":"1.1 Tentang Version Control \u00b6 Bab ini akan membahas tentang memulai dengan Git. Kita akan mulai dengan menjelaskan beberapa latar belakang pada peralatan version control , kemudian beralih ke bagaimana cara agar Git dapat berjalan pada sistem Anda, dan terakhir, bagaimana cara mengaturnya agar dapat mulai bekerja dengan Git. Pada akhir bab ini Anda seharusnya telah paham mengapa Git ada, mengapa sebaiknya Anda menggunakannya dan sebaiknya Anda sudah siap untuk melakukannya. Apa itu Version Control? \u00b6 Apa itu version control dan mengapa sebaiknya Anda peduli? Version control adalah sebuah sistem yang merekam perubahan-perubahan dari sebuah berkas atau sekumpulan berkas dari waktu ke waktu sehingga Anda dapat menilik kembali versi khusus suatu saat nanti. Sebagai contoh, pada buku ini Anda akan menggunakan sumber kode perangkat lunak sebagai berkas-berkas yang direkam dengan version control , walau pada kenyataannya Anda dapat melakukan ini dengan hampir semua jenis berkas pada komputer. Jika Anda adalah seorang perancang grafis atau web dan ingin menyimpan setiap versi dari sebuah gambar atau layout (yang tentunya Anda ingin melakukannya), sebuah Version Control System (VCS) adalah hal yang bijak untuk digunakan. VCS memperbolehkan Anda untuk mengembalikan berkas-berkas ke keadaan sebelumnya, mengembalikan seluruh proyek kembali ke keadaan sebelumnya, membandingkan perubahan-perubahan di setiap waktu, melihat siapa yang terakhir mengubah sesuatu yang mungkin menimbulkan masalah, siapa dan kapan yang mengenalkan sebuah isu dan banyak lagi. Menggunakan VCS secara umum juga berarti bahwa jika Anda melakukan kesalahan atau menghilangkan berkas, Anda dapat dengan mudah memulihkannya. Sebagai tambahan, Anda mendapatkan semua ini dengan biaya yang sangat sedikit. Sistem Version Control Lokal \u00b6 Metode version control yang banyak dipilih oleh orang-orang adalah dengan menyalin berkas-berkas ke direktori lain (mungkin direktori yang diberi catatan waktu, jika mereka cerdas). Pendekatan ini sangat umum karena ini sangat sederhana, namun ini juga sangat rentan terkena galat. Mudah sekali untuk lupa pada direktori mana Anda sedang berada dan menulis ke berkas yang salah atau menyalin setiap berkas yang bukan Anda maksud secara tidak sengaja. Untuk menghadapi hal ini, dahulu para programmer mengembangkan VCS lokal yang memiliki database sederhana yang menyimpan semua perubahan pada berkas pada revision control . diagram version control lokal Salah satu alat VCS yang lebih terkenal adalah sistem yang disebut dengan RCS, yang masih disebarkan dengan banyak komputer saat ini. Bahkan sistem operasi Mac OS X yang terkenal menyertakan perintah rcs ketika Anda memasang Developer Tools. RCS bekerja dengan cara menyimpan sekumpulan patch (itulah, perbedaan antara berkas-berkas) dalam sebuah format dalam diska; itu kemudian dapat membuat ulang sebarang berkas yang terlihat sama pada satu waktu dengan menambahkan semua patch . Sistem Version Control Terpusat \u00b6 Masalah besar selanjutnya yang dihadapi orang-orang adalah bahwa mereka butuh bekerja bersama dengan para pengembang pada sistem lain. Untuk menangani masalah ini, Centralized Version Control System (CVCS) dikembangkan. Sistem-sistem ini, seperti CVS , Subversion , dan Perforce , memiliki sebuah server tunggal yang berisi semua berkas-berkas yang telah diberi versi, dan beberapa klien yang melakukan check out pada berkas-berkas dari pusat tersebut. Selama bertahun-tahun, hal ini telah menjadi standar untuk version control . Diagram version control terpusat Pengaturan ini menawarkan banyak keuntungan, terutama dibandingkan dengan VCS lokal. Contohnya, setiap orang tahu hingga pada tahapan apa yang orang lain sedang kerjakan di dalam proyek. Para administrator memiliki kendali yang baik mengenai siapa dapat melakukan apa; dan itu jauh lebih mudah untuk mengelola sebuah CVCS daripada menangani database lokal pada setiap klien. Akan tetapi, pengaturan ini juga memiliki beberapa kekurangan. Yang paling jelas adalah satu titik kegagalan yang diwakili oleh server terpusat . Jika server tersebut sedang down selama satu jam, maka selama itu tidak ada orang yang dapat bekerja bersama atau menyimpan perubahan yang telah diberi versi terhadap apapun yang sedang mereka kerjakan. Jika hard disk dari database pusat menjadi corrupted , dan cadangan yang memadai belum tersimpan, Anda akan kehilangan segalanya \u2013 seluruh riwayat dari proyek kecuali setiap snapshot yang dimiliki oleh orang-orang pada mesin lokal mereka. Sistem VCS lokal menderita dari hal yang sama pula \u2013 ketika Anda memiliki semua riwayat dari proyek pada satu tempat, Anda memiliki resiko untuk kehilangan semuanya. Sistem Version Control Tersebar \u00b6 Di sinilah Distributed Version Control System (DVCS) masuk. Pada DVCS (seperti Git, Mercurial, Bazaar atau Darcs), para klien tidak hanya melakukan check out pada snapshot terakhir dari berkas: mereka mencerminkan sepenuhnya repository tersebut. Dan juga, jika ada salah satu server yang mati, dan sistem-sistem ini bekerja bersama melalui server itu, setiap repository milik klien dapat disalin kembali ke server untuk memulihkannya. Setiap check out benar-benar cadangan penuh dari semua data. Sistem version control tersebar. Selebihnya, banyak dari sistem ini mampu menangani beberapa remote repository yang dapat mereka kerjakan dengan baik, sehingga Anda dapat bekerja bersama dengan beberapa kelompok orang yang berbeda dengan cara yang berbeda secara bersamaan dalam proyek yang sama. Kemampuan ini memperbolehkan Anda untuk mengatur beberapa jenis alur kerja yang tidak mungkin dilakukan pada sistem terpusat, seperti model hirarkial.","title":"(VSC) Version Control"},{"location":"belajar/git/version-control/#11-tentang-version-control","text":"Bab ini akan membahas tentang memulai dengan Git. Kita akan mulai dengan menjelaskan beberapa latar belakang pada peralatan version control , kemudian beralih ke bagaimana cara agar Git dapat berjalan pada sistem Anda, dan terakhir, bagaimana cara mengaturnya agar dapat mulai bekerja dengan Git. Pada akhir bab ini Anda seharusnya telah paham mengapa Git ada, mengapa sebaiknya Anda menggunakannya dan sebaiknya Anda sudah siap untuk melakukannya.","title":"1.1 Tentang Version Control"},{"location":"belajar/git/version-control/#apa-itu-version-control","text":"Apa itu version control dan mengapa sebaiknya Anda peduli? Version control adalah sebuah sistem yang merekam perubahan-perubahan dari sebuah berkas atau sekumpulan berkas dari waktu ke waktu sehingga Anda dapat menilik kembali versi khusus suatu saat nanti. Sebagai contoh, pada buku ini Anda akan menggunakan sumber kode perangkat lunak sebagai berkas-berkas yang direkam dengan version control , walau pada kenyataannya Anda dapat melakukan ini dengan hampir semua jenis berkas pada komputer. Jika Anda adalah seorang perancang grafis atau web dan ingin menyimpan setiap versi dari sebuah gambar atau layout (yang tentunya Anda ingin melakukannya), sebuah Version Control System (VCS) adalah hal yang bijak untuk digunakan. VCS memperbolehkan Anda untuk mengembalikan berkas-berkas ke keadaan sebelumnya, mengembalikan seluruh proyek kembali ke keadaan sebelumnya, membandingkan perubahan-perubahan di setiap waktu, melihat siapa yang terakhir mengubah sesuatu yang mungkin menimbulkan masalah, siapa dan kapan yang mengenalkan sebuah isu dan banyak lagi. Menggunakan VCS secara umum juga berarti bahwa jika Anda melakukan kesalahan atau menghilangkan berkas, Anda dapat dengan mudah memulihkannya. Sebagai tambahan, Anda mendapatkan semua ini dengan biaya yang sangat sedikit.","title":"Apa itu Version Control?"},{"location":"belajar/git/version-control/#sistem-version-control-lokal","text":"Metode version control yang banyak dipilih oleh orang-orang adalah dengan menyalin berkas-berkas ke direktori lain (mungkin direktori yang diberi catatan waktu, jika mereka cerdas). Pendekatan ini sangat umum karena ini sangat sederhana, namun ini juga sangat rentan terkena galat. Mudah sekali untuk lupa pada direktori mana Anda sedang berada dan menulis ke berkas yang salah atau menyalin setiap berkas yang bukan Anda maksud secara tidak sengaja. Untuk menghadapi hal ini, dahulu para programmer mengembangkan VCS lokal yang memiliki database sederhana yang menyimpan semua perubahan pada berkas pada revision control . diagram version control lokal Salah satu alat VCS yang lebih terkenal adalah sistem yang disebut dengan RCS, yang masih disebarkan dengan banyak komputer saat ini. Bahkan sistem operasi Mac OS X yang terkenal menyertakan perintah rcs ketika Anda memasang Developer Tools. RCS bekerja dengan cara menyimpan sekumpulan patch (itulah, perbedaan antara berkas-berkas) dalam sebuah format dalam diska; itu kemudian dapat membuat ulang sebarang berkas yang terlihat sama pada satu waktu dengan menambahkan semua patch .","title":"Sistem Version Control Lokal"},{"location":"belajar/git/version-control/#sistem-version-control-terpusat","text":"Masalah besar selanjutnya yang dihadapi orang-orang adalah bahwa mereka butuh bekerja bersama dengan para pengembang pada sistem lain. Untuk menangani masalah ini, Centralized Version Control System (CVCS) dikembangkan. Sistem-sistem ini, seperti CVS , Subversion , dan Perforce , memiliki sebuah server tunggal yang berisi semua berkas-berkas yang telah diberi versi, dan beberapa klien yang melakukan check out pada berkas-berkas dari pusat tersebut. Selama bertahun-tahun, hal ini telah menjadi standar untuk version control . Diagram version control terpusat Pengaturan ini menawarkan banyak keuntungan, terutama dibandingkan dengan VCS lokal. Contohnya, setiap orang tahu hingga pada tahapan apa yang orang lain sedang kerjakan di dalam proyek. Para administrator memiliki kendali yang baik mengenai siapa dapat melakukan apa; dan itu jauh lebih mudah untuk mengelola sebuah CVCS daripada menangani database lokal pada setiap klien. Akan tetapi, pengaturan ini juga memiliki beberapa kekurangan. Yang paling jelas adalah satu titik kegagalan yang diwakili oleh server terpusat . Jika server tersebut sedang down selama satu jam, maka selama itu tidak ada orang yang dapat bekerja bersama atau menyimpan perubahan yang telah diberi versi terhadap apapun yang sedang mereka kerjakan. Jika hard disk dari database pusat menjadi corrupted , dan cadangan yang memadai belum tersimpan, Anda akan kehilangan segalanya \u2013 seluruh riwayat dari proyek kecuali setiap snapshot yang dimiliki oleh orang-orang pada mesin lokal mereka. Sistem VCS lokal menderita dari hal yang sama pula \u2013 ketika Anda memiliki semua riwayat dari proyek pada satu tempat, Anda memiliki resiko untuk kehilangan semuanya.","title":"Sistem Version Control Terpusat"},{"location":"belajar/git/version-control/#sistem-version-control-tersebar","text":"Di sinilah Distributed Version Control System (DVCS) masuk. Pada DVCS (seperti Git, Mercurial, Bazaar atau Darcs), para klien tidak hanya melakukan check out pada snapshot terakhir dari berkas: mereka mencerminkan sepenuhnya repository tersebut. Dan juga, jika ada salah satu server yang mati, dan sistem-sistem ini bekerja bersama melalui server itu, setiap repository milik klien dapat disalin kembali ke server untuk memulihkannya. Setiap check out benar-benar cadangan penuh dari semua data. Sistem version control tersebar. Selebihnya, banyak dari sistem ini mampu menangani beberapa remote repository yang dapat mereka kerjakan dengan baik, sehingga Anda dapat bekerja bersama dengan beberapa kelompok orang yang berbeda dengan cara yang berbeda secara bersamaan dalam proyek yang sama. Kemampuan ini memperbolehkan Anda untuk mengatur beberapa jenis alur kerja yang tidak mungkin dilakukan pada sistem terpusat, seperti model hirarkial.","title":"Sistem Version Control Tersebar"},{"location":"belajar/shell/","text":"Belajar Shell \u00b6 Script Shell adalah program komputer yang dirancang oleh shell Unix/Linux yang dapat berupa salah satunya adalah: Bourne Shell C Shell Korn Shell GNU bourne-again Shell Shell adalah penerjemah baris perintah dan operasi tipikal yang dilakukan oleh skrip shell termasuk manipulasi file, eksekusi program, dan pencetakan teks. Skrip shell memiliki beberapa konstruksi yang diperlakukan yang memberi tahu lingkungan shell apa yang harus dilakukan dan kapan melakukannya. tentu saja, sebagian besar skrip lebih kompleks. Bagaimanapun juga, shell adalah bahasa pemograman yang nyata, lengkap dengan variable, struktur kontrol, dan sebagainya. tidak perduli sberapa rumit sebuah skrip, itu masih hanya daftar perintah yang dieksekusi secara berurutan. Permulaan \u00b6 Windows Dari Windows menyarankan untuk mengaktifkan Windows Subsystem for Linux untuk menjalankan program shell. Linux atau Mac OS Kita tidak perlu mengaktifkan beberapa kebutuhan dan lain-lain karena shell ini dirancang untuk Linux dan Mac OS(Unix). Note Menjalankan file bash filename","title":"Shell"},{"location":"belajar/shell/#belajar-shell","text":"Script Shell adalah program komputer yang dirancang oleh shell Unix/Linux yang dapat berupa salah satunya adalah: Bourne Shell C Shell Korn Shell GNU bourne-again Shell Shell adalah penerjemah baris perintah dan operasi tipikal yang dilakukan oleh skrip shell termasuk manipulasi file, eksekusi program, dan pencetakan teks. Skrip shell memiliki beberapa konstruksi yang diperlakukan yang memberi tahu lingkungan shell apa yang harus dilakukan dan kapan melakukannya. tentu saja, sebagian besar skrip lebih kompleks. Bagaimanapun juga, shell adalah bahasa pemograman yang nyata, lengkap dengan variable, struktur kontrol, dan sebagainya. tidak perduli sberapa rumit sebuah skrip, itu masih hanya daftar perintah yang dieksekusi secara berurutan.","title":"Belajar Shell"},{"location":"belajar/shell/#permulaan","text":"Windows Dari Windows menyarankan untuk mengaktifkan Windows Subsystem for Linux untuk menjalankan program shell. Linux atau Mac OS Kita tidak perlu mengaktifkan beberapa kebutuhan dan lain-lain karena shell ini dirancang untuk Linux dan Mac OS(Unix). Note Menjalankan file bash filename","title":"Permulaan"},{"location":"belajar/shell/array/","text":"Array \u00b6 Array adalah sebuah metode dimana didalamnya terdapat beberapa string ataupun angka. Lalu apa si fungsinya si array ini?. Mari kita kupas tuntas, kenapa array itu penting Kita ambil contoh aja seperti ini semisalnya kita ingin membuat banyak data tapi data itu hanya disimpan saja tidak ditampilkan atau hanya bisa diakses dengan cara mengambil data arraynya saja. Maka array adalah cara yang tepat. Contohnya kaya gini yaitu tentang nama nama buah echo \"apel\" echo \"mangga\" echo \"anggur\" Jika kita lakukan seperti diatas tidak efisien apalagi kita hanya ingin apel saja yang ingin kita tampilkan bukan mangga dan anggur . Lalu bagaimana dengan struktur dari array ? Seperti inilah strukturnya. var =( 'string' 'string' 'string' ) echo \" ${ var [@] } \" Nah sebelum lanjut kecontoh pasti bingung dengan tanda ${var[@]} , nah mari simak dulu apa si fungsinya echo \"${var[@]}\" => Berarti mengambil isi data array secara keseluruhan echo \"${var[0]}\" => Mengambil nilai data dari index 0 echo \"${#var[@]}\" => Menghitung panjang array echo \"${!var[@]}\" => Berarti menampilkan setiap data itu dari index ke berapa Nah mari kita coba membuat array dengan variabel buah dan isi datanya itu apel, mangga, angur 1 2 3 4 5 buah =( 'apel' 'mangga' 'anggur' ) echo \"Nama Buahnya adalah : ${ buah [@] } \" echo \"Nama Buah Index 0 : ${ buah [0] } \" echo \"Panjang Array : ${# buah [@] } \" echo \"Index Setiap Buah : ${ !buah[@] } \" Output 1 2 3 4 Nama Buahnya adalah : apel mangga anggur Nama Buah Index 0 : apel Panjang Array : 3 Index Setiap Buah : 0 1 2 Oke semisalnya kita ingin mengubah salah satu data dan memasukan data baru apakah bisa ? Sudah tentu bisa kita akan menggunakan var[index]=\"data_baru\" . Contohnya seperti ini 1 2 3 4 5 6 7 buah =( 'apel' 'mangga' 'anggur' ) buah [ 3 ]= \"semangka\" buah [ 0 ]= \"pir\" echo \"Nama Buahnya adalah : ${ buah [@] } \" echo \"Nama Buah Index 0 : ${ buah [0] } \" echo \"Panjang Array : ${# buah [@] } \" echo \"Index Setiap Buah : ${ !buah[@] } \" Output 1 2 3 4 Nama Buahnya adalah : pir mangga anggur semangka Nama Buah Index 0 : pir Panjang Array : 4 Index Setiap Buah : 0 1 2 3 Di line 2 script diatas itu menambahkan data di index 3 dan line 3 mengubah index 0 menjadi pir Lalu bagaimana ketika kita ingin menghapus data array ? Mudah sekali kita bisa menggunakan method unset jadi yang kita lakukan itu unset var[index] , contohnya #!/bin/bash buah =( 'apel' 'mangga' 'anggur' ) buah [ 3 ]= \"semangka\" buah [ 0 ]= \"pir\" unset buah [ 1 ] echo \"Nama Buahnya adalah : ${ buah [@] } \" echo \"Nama Buah Index 0 : ${ buah [0] } \" echo \"Panjang Array : ${# buah [@] } \" echo \"Index Setiap Buah : ${ !buah[@] } \" # Output: # Nama Buahnya adalah : pir anggur semangka # Nama Buah Index 0 : pir # Panjang Array : 3 # Index Setiap Buah : 0 2 3 Slice \u00b6 Slice ialah metode dimana memotong array dari index berapapun. Maksudnya bagaimana? contohnya kita ingin data arra yang ditampilkan itu tidak dari awal namun dari data ke 5 sampai 7 semisalnya, nah metode yang kita gunakan itu bernama slice. Oke kita ambil contohnya seperti ini arr =( \"apel\" \"mangga\" \"rambutan\" \"semangka\" \"melon\" ) echo \" ${ arr [@] } \" # Ouput : apel mangga rambutan semangka melon Nah bagaimana untuk mengambil datanya, oke kita liat table berikut ini Symbol Deskripsi [@]:i Mengambil data dari i awal sampai akhir [@]:i:x Mengambil data awal i sampai data akhir yang ditentukan x [@]:-i Mengambil data awal -i dari belakang [@]:-i:x Mengambil data awal -i dari belakang sampai data akhir x Dari diatas semisalnya kita ingin mengambil data rambutan sampai dengan melon, bisa dilakukan dengan slice dengan cara seperti ini arr =( \"apel\" \"mangga\" \"rambutan\" \"semangka\" \"melon\" ) echo \" ${ arr [@]: 2 } \" output rambutan, semangka, melon Lalu bagaimana dengan kita yang ingin mengambil data array dari -i , apakah itu sama? Berbeda dengan yang tadi data awal dihitung 0 , namun ketika kita mengambil dari belakang awalan berubah menjadi -1 jadi ketika kita mengambil data dari belakang , contohnya -3 maka hasilnya akan seperti ini arr =( \"apel\" \"mangga\" \"rambutan\" \"semangka\" \"melon\" ) echo \" ${ arr [@]: -3 } \" output rambutan, semangka, melon Sama saja dengan contoh pertama namun data yang diambil dari belakang. Semisalnya kita ingin mengambil data dari -3: -2 apakah bisa? Tidak bisa , jika dilakukan seperti itu akan terjadi error seperti ini arr =( \"apel\" \"mangga\" \"rambutan\" \"semangka\" \"melon\" ) echo \" ${ arr [@]: -3: -2 } \" output line 2: -4: substring expression < 0 Jadi ketika kita membuat slice index akhir tidak boleh kurang dari 0, nilainya harus angka positif Note: Uniknya untuk array kita bebas ingin menambahkan index ke berapa","title":"Array"},{"location":"belajar/shell/array/#array","text":"Array adalah sebuah metode dimana didalamnya terdapat beberapa string ataupun angka. Lalu apa si fungsinya si array ini?. Mari kita kupas tuntas, kenapa array itu penting Kita ambil contoh aja seperti ini semisalnya kita ingin membuat banyak data tapi data itu hanya disimpan saja tidak ditampilkan atau hanya bisa diakses dengan cara mengambil data arraynya saja. Maka array adalah cara yang tepat. Contohnya kaya gini yaitu tentang nama nama buah echo \"apel\" echo \"mangga\" echo \"anggur\" Jika kita lakukan seperti diatas tidak efisien apalagi kita hanya ingin apel saja yang ingin kita tampilkan bukan mangga dan anggur . Lalu bagaimana dengan struktur dari array ? Seperti inilah strukturnya. var =( 'string' 'string' 'string' ) echo \" ${ var [@] } \" Nah sebelum lanjut kecontoh pasti bingung dengan tanda ${var[@]} , nah mari simak dulu apa si fungsinya echo \"${var[@]}\" => Berarti mengambil isi data array secara keseluruhan echo \"${var[0]}\" => Mengambil nilai data dari index 0 echo \"${#var[@]}\" => Menghitung panjang array echo \"${!var[@]}\" => Berarti menampilkan setiap data itu dari index ke berapa Nah mari kita coba membuat array dengan variabel buah dan isi datanya itu apel, mangga, angur 1 2 3 4 5 buah =( 'apel' 'mangga' 'anggur' ) echo \"Nama Buahnya adalah : ${ buah [@] } \" echo \"Nama Buah Index 0 : ${ buah [0] } \" echo \"Panjang Array : ${# buah [@] } \" echo \"Index Setiap Buah : ${ !buah[@] } \" Output 1 2 3 4 Nama Buahnya adalah : apel mangga anggur Nama Buah Index 0 : apel Panjang Array : 3 Index Setiap Buah : 0 1 2 Oke semisalnya kita ingin mengubah salah satu data dan memasukan data baru apakah bisa ? Sudah tentu bisa kita akan menggunakan var[index]=\"data_baru\" . Contohnya seperti ini 1 2 3 4 5 6 7 buah =( 'apel' 'mangga' 'anggur' ) buah [ 3 ]= \"semangka\" buah [ 0 ]= \"pir\" echo \"Nama Buahnya adalah : ${ buah [@] } \" echo \"Nama Buah Index 0 : ${ buah [0] } \" echo \"Panjang Array : ${# buah [@] } \" echo \"Index Setiap Buah : ${ !buah[@] } \" Output 1 2 3 4 Nama Buahnya adalah : pir mangga anggur semangka Nama Buah Index 0 : pir Panjang Array : 4 Index Setiap Buah : 0 1 2 3 Di line 2 script diatas itu menambahkan data di index 3 dan line 3 mengubah index 0 menjadi pir Lalu bagaimana ketika kita ingin menghapus data array ? Mudah sekali kita bisa menggunakan method unset jadi yang kita lakukan itu unset var[index] , contohnya #!/bin/bash buah =( 'apel' 'mangga' 'anggur' ) buah [ 3 ]= \"semangka\" buah [ 0 ]= \"pir\" unset buah [ 1 ] echo \"Nama Buahnya adalah : ${ buah [@] } \" echo \"Nama Buah Index 0 : ${ buah [0] } \" echo \"Panjang Array : ${# buah [@] } \" echo \"Index Setiap Buah : ${ !buah[@] } \" # Output: # Nama Buahnya adalah : pir anggur semangka # Nama Buah Index 0 : pir # Panjang Array : 3 # Index Setiap Buah : 0 2 3","title":"Array"},{"location":"belajar/shell/array/#slice","text":"Slice ialah metode dimana memotong array dari index berapapun. Maksudnya bagaimana? contohnya kita ingin data arra yang ditampilkan itu tidak dari awal namun dari data ke 5 sampai 7 semisalnya, nah metode yang kita gunakan itu bernama slice. Oke kita ambil contohnya seperti ini arr =( \"apel\" \"mangga\" \"rambutan\" \"semangka\" \"melon\" ) echo \" ${ arr [@] } \" # Ouput : apel mangga rambutan semangka melon Nah bagaimana untuk mengambil datanya, oke kita liat table berikut ini Symbol Deskripsi [@]:i Mengambil data dari i awal sampai akhir [@]:i:x Mengambil data awal i sampai data akhir yang ditentukan x [@]:-i Mengambil data awal -i dari belakang [@]:-i:x Mengambil data awal -i dari belakang sampai data akhir x Dari diatas semisalnya kita ingin mengambil data rambutan sampai dengan melon, bisa dilakukan dengan slice dengan cara seperti ini arr =( \"apel\" \"mangga\" \"rambutan\" \"semangka\" \"melon\" ) echo \" ${ arr [@]: 2 } \" output rambutan, semangka, melon Lalu bagaimana dengan kita yang ingin mengambil data array dari -i , apakah itu sama? Berbeda dengan yang tadi data awal dihitung 0 , namun ketika kita mengambil dari belakang awalan berubah menjadi -1 jadi ketika kita mengambil data dari belakang , contohnya -3 maka hasilnya akan seperti ini arr =( \"apel\" \"mangga\" \"rambutan\" \"semangka\" \"melon\" ) echo \" ${ arr [@]: -3 } \" output rambutan, semangka, melon Sama saja dengan contoh pertama namun data yang diambil dari belakang. Semisalnya kita ingin mengambil data dari -3: -2 apakah bisa? Tidak bisa , jika dilakukan seperti itu akan terjadi error seperti ini arr =( \"apel\" \"mangga\" \"rambutan\" \"semangka\" \"melon\" ) echo \" ${ arr [@]: -3: -2 } \" output line 2: -4: substring expression < 0 Jadi ketika kita membuat slice index akhir tidak boleh kurang dari 0, nilainya harus angka positif Note: Uniknya untuk array kita bebas ingin menambahkan index ke berapa","title":"Slice"},{"location":"belajar/shell/bc-command/","text":"Perintah BC \u00b6 BC Command ialah merupakan command yang telah disediakan oleh bash dalam meng-operasikan bilangan. Uniknya di bc ini kita bisa meng-operasikan antara bilangan integer dan bilangan float , menarik bukan. Mari kita bahas tuntas tentang BC Command Method bc ialah sebuah method yang dimana method dari singkatan basic calculator dimana disin kita dapat melakukan operasi matematika dengan bilangan apapun. Lalu bagaimana formatnya? Nah formatnya seperti ini variabel1 = num variabel2 = num echo $variabel1 + $variabel2 | bc Loh heh formatnya seperti itu saja? mudah banget dong. Ya tentu saja inilah yang menarik dari bash dimana kita bisa membuat script kita menjadi lebih efisien, lalu apakah bisa digunakan dengan oneline script? Bisa saja contoh formatnya seperti ini echo \"var=num;var+=20.5;var\" | bc Nah uniknya kita bisa representasikan operator dengan sangat mudah disini, misalkan seperti ini Deskripsi tipe Ketika kita ingin menambahkan number sebelumnya dengan number baru bisa menggunakan += Ketika kita ingin mengurangi number sebelumnya dengan number baru bisa menggunakan -= Ketika kita ingin mengkalikan number sebelumnya dengan number baru bisa menggunakan *= Ketika kita ingin membagikan number sebelumnya dengan number baru bisa menggunakan /= Ketika kita ingin mempangkatkan number sebelumnya dengan number baru bisa menggunakan ^= Ketika kita ingin sisa bagi number sebelumnya dengan number baru bisa menggunakan %= Lalu bagaimana dengan contohnya? Contohnya sangat mudah , seperti ini variabel1 = 10 .5 variabel2 = 10 echo $variabel1 + $variabel2 | bc Output 20.5 Selain contoh diatas kita bisa juga menggunakan script oneline yang dimana meng-efisiensi waktu kita dalam ngoding di bash ini 1 2 3 4 5 6 echo \"num=50;num+=20;num\" | bc echo \"num=50;num-=20;num\" | bc echo \"num=50;num*=20;num\" | bc echo \"num=50;num/=20;num\" | bc echo \"num=50;num^=20;num\" | bc echo \"num=50;num%=20;num\" | bc Outputnya: 1 2 3 4 5 6 70 30 1000 2 9536743164062500000000000000000000 10","title":"BC Command"},{"location":"belajar/shell/bc-command/#perintah-bc","text":"BC Command ialah merupakan command yang telah disediakan oleh bash dalam meng-operasikan bilangan. Uniknya di bc ini kita bisa meng-operasikan antara bilangan integer dan bilangan float , menarik bukan. Mari kita bahas tuntas tentang BC Command Method bc ialah sebuah method yang dimana method dari singkatan basic calculator dimana disin kita dapat melakukan operasi matematika dengan bilangan apapun. Lalu bagaimana formatnya? Nah formatnya seperti ini variabel1 = num variabel2 = num echo $variabel1 + $variabel2 | bc Loh heh formatnya seperti itu saja? mudah banget dong. Ya tentu saja inilah yang menarik dari bash dimana kita bisa membuat script kita menjadi lebih efisien, lalu apakah bisa digunakan dengan oneline script? Bisa saja contoh formatnya seperti ini echo \"var=num;var+=20.5;var\" | bc Nah uniknya kita bisa representasikan operator dengan sangat mudah disini, misalkan seperti ini Deskripsi tipe Ketika kita ingin menambahkan number sebelumnya dengan number baru bisa menggunakan += Ketika kita ingin mengurangi number sebelumnya dengan number baru bisa menggunakan -= Ketika kita ingin mengkalikan number sebelumnya dengan number baru bisa menggunakan *= Ketika kita ingin membagikan number sebelumnya dengan number baru bisa menggunakan /= Ketika kita ingin mempangkatkan number sebelumnya dengan number baru bisa menggunakan ^= Ketika kita ingin sisa bagi number sebelumnya dengan number baru bisa menggunakan %= Lalu bagaimana dengan contohnya? Contohnya sangat mudah , seperti ini variabel1 = 10 .5 variabel2 = 10 echo $variabel1 + $variabel2 | bc Output 20.5 Selain contoh diatas kita bisa juga menggunakan script oneline yang dimana meng-efisiensi waktu kita dalam ngoding di bash ini 1 2 3 4 5 6 echo \"num=50;num+=20;num\" | bc echo \"num=50;num-=20;num\" | bc echo \"num=50;num*=20;num\" | bc echo \"num=50;num/=20;num\" | bc echo \"num=50;num^=20;num\" | bc echo \"num=50;num%=20;num\" | bc Outputnya: 1 2 3 4 5 6 70 30 1000 2 9536743164062500000000000000000000 10","title":"Perintah BC"},{"location":"belajar/shell/break/","text":"Break \u00b6 Break adalah sebuah method yang dimana ketika kondisi telah memenuhi syarat maka akan berhenti, kondisi ini biasanya dipakai dalam perulangan ataupun instruksi logika . Lalu kenapa si break ini penting kita ambil contoh aja loop , disini kita ingin menampikan data yang kita inginkan saja dan data yang tidak penting maka tidak ditampilkan, contohnya seperti ini for (( num = 1 ; num< = 15 ; num++ )) do if (( $num > 7 )) then break fi echo $num done Dimana hasil outputnya ialah 1,2,3,4,5,6,7 , nah disini kita tahu bahwa angka yang lebih 7 itu tidak ditampilkan dan akan lanjut ke statement berikutnya. Oke next kita bahas continue","title":"Break"},{"location":"belajar/shell/break/#break","text":"Break adalah sebuah method yang dimana ketika kondisi telah memenuhi syarat maka akan berhenti, kondisi ini biasanya dipakai dalam perulangan ataupun instruksi logika . Lalu kenapa si break ini penting kita ambil contoh aja loop , disini kita ingin menampikan data yang kita inginkan saja dan data yang tidak penting maka tidak ditampilkan, contohnya seperti ini for (( num = 1 ; num< = 15 ; num++ )) do if (( $num > 7 )) then break fi echo $num done Dimana hasil outputnya ialah 1,2,3,4,5,6,7 , nah disini kita tahu bahwa angka yang lebih 7 itu tidak ditampilkan dan akan lanjut ke statement berikutnya. Oke next kita bahas continue","title":"Break"},{"location":"belajar/shell/continue/","text":"Continue \u00b6 Continue adalah sebuah method yang dimana ketika kondisi telah memenuhi syarat maka akan lanjut ke statement berikutnya. Loh heh, apa bedanya dengan break? Jadi gini si break kan akan melakukan berhenti ketika angkanya memang memenuhi syarat contohnya kaya contoh diatas 15 emang lebih dari 7. Dan akhirnya break terjadi. Oke kita ambil contoh seperti ini for (( num = 1 ; num< = 15 ; num++ )) do if (( $num < 7 )) then break fi echo $num done Maka akan yang terjadi tidak menampilkan output apa apa, loh heh kenapa? karena dikondisi mengatakan bahwa angka yang kurang dari 7 akan break yo sudah jelas dari awal sudah terpenuhi dan pasti akan ke break . Nah lalu bagaimana dengan continue kita samakan seperti diatas, tapi methodnya kita ubah ke continue for (( num = 1 ; num< = 15 ; num++ )) do if (( $num < 7 )) then continue fi echo $num done Nah berbeda di atas , kondisi terpenuhi maka angka yang dibawah 7 tidak ditampilkan melainkan angka yang di atas 7 lah yang ditampilkan","title":"Continue"},{"location":"belajar/shell/continue/#continue","text":"Continue adalah sebuah method yang dimana ketika kondisi telah memenuhi syarat maka akan lanjut ke statement berikutnya. Loh heh, apa bedanya dengan break? Jadi gini si break kan akan melakukan berhenti ketika angkanya memang memenuhi syarat contohnya kaya contoh diatas 15 emang lebih dari 7. Dan akhirnya break terjadi. Oke kita ambil contoh seperti ini for (( num = 1 ; num< = 15 ; num++ )) do if (( $num < 7 )) then break fi echo $num done Maka akan yang terjadi tidak menampilkan output apa apa, loh heh kenapa? karena dikondisi mengatakan bahwa angka yang kurang dari 7 akan break yo sudah jelas dari awal sudah terpenuhi dan pasti akan ke break . Nah lalu bagaimana dengan continue kita samakan seperti diatas, tapi methodnya kita ubah ke continue for (( num = 1 ; num< = 15 ; num++ )) do if (( $num < 7 )) then continue fi echo $num done Nah berbeda di atas , kondisi terpenuhi maka angka yang dibawah 7 tidak ditampilkan melainkan angka yang di atas 7 lah yang ditampilkan","title":"Continue"},{"location":"belajar/shell/enviroment-variable/","text":"Environment Variables \u00b6 Pengertian \u00b6 Environment variables adalah variabel yang tersimpan di environment shell dan menyimpan data mengenai environment / OS yang digunakan. Contoh \u00b6 Beberapa contoh environment variables yang umum digunakan: Variabel Deskripsi $HOME Lokasi direktori /home dari user $PREFIX Path ke direktori /usr $PATH Kumpulan path untuk mencari lokasi package yang dijalankan $PWD Lokasi direktori yang ditempati $SHELL Lokasi shell yang digunakan Mendapatkan Daftar Environment Variables Yang Ada \u00b6 Untuk melihat Environment Variables yang ada, ketikkan printenv di Terminal. Sebagai contoh, di Ubuntu 20.04 unity: [ I ] \u25c6 shell git: ( main ) \u2717 \u276f\u276f\u276f printenv COMPIZ_CONFIG_PROFILE = ubuntu LANG = en_US.UTF-8 CLUTTER_IM_MODULE = ibus GEM_PATH = /home/memet/.rvm/gems/ruby-3.0.3:/home/memet/.rvm/gems/ruby-3.0.3@global DBUS_SESSION_BUS_ADDRESS = unix:path = /run/user/1000/bus GDMSESSION = unity XAUTHORITY = /run/user/1000/gdm/Xauthority LC_PAPER = id_ID.UTF-8 XDG_MENU_PREFIX = gnome- GEM_HOME = /home/memet/.rvm/gems/ruby-3.0.3 rvm_bin_path = /home/memet/.rvm/bin QT4_IM_MODULE = ibus KOTLIN_HOME = /home/memet/.sdkman/candidates/kotlin/current XDG_SESSION_DESKTOP = unity VTE_VERSION = 6003 MY_RUBY_HOME = /home/memet/.rvm/rubies/ruby-3.0.3 .... Dapat dilihat, environment variables yang ada di Ubuntu sangat banyak, beberapa juga berhubungan dengan sistem. Environment Variables pada tiap sistem berbeda-beda! Environment Variables Sistem \u00b6 Environment Variables sistem adalah environment variables yang tersedia secara bawaan dari OS yang digunakan. Seperti $HOSTNAME , $USER , $UID , dan lain-lain. Variabel-variabel ini tidak ada di printenv , melainkan dari file sistem, seperti: $HOSTNAME => /etc/hostname . Beberapa variabel terdapat pada file sistem yang tersembunyi. Menambahkan Environment Variables \u00b6 Anda dapat menambahkan environment variables Anda sendiri sehingga dapat diakses oleh semua proses dalam satu shell. Jalankan perintah: [ I ] \u25c6 shell git: ( main ) \u2717 \u276f\u276f\u276f export namaVariabel = isiVariabel [ I ] \u25c6 shell git: ( main ) \u2717 \u276f\u276f\u276f env | grep namaVariabel namaVariabel = isiVariabel untuk menambah environment variable, dimana namaVariabel merupakan nama dari variabel dan isiVariabeel adalah isi/value dari variabel. export merupakan perintah yang digunakan untuk mengekspor variabel ke dalam environment variables. Perlu diketahui bahwa environment variable yang Anda tambahkan hanya bersifat sementara dan hanya dapat diakses oleh shell yang digunakan. Jika Anda menggunakan shell lain atau membuka ulang shell, maka variabel tersebut akan terhapus/tidak ditemukan.","title":"Enviroment Variabels"},{"location":"belajar/shell/enviroment-variable/#environment-variables","text":"","title":"Environment Variables"},{"location":"belajar/shell/enviroment-variable/#pengertian","text":"Environment variables adalah variabel yang tersimpan di environment shell dan menyimpan data mengenai environment / OS yang digunakan.","title":"Pengertian"},{"location":"belajar/shell/enviroment-variable/#contoh","text":"Beberapa contoh environment variables yang umum digunakan: Variabel Deskripsi $HOME Lokasi direktori /home dari user $PREFIX Path ke direktori /usr $PATH Kumpulan path untuk mencari lokasi package yang dijalankan $PWD Lokasi direktori yang ditempati $SHELL Lokasi shell yang digunakan","title":"Contoh"},{"location":"belajar/shell/enviroment-variable/#mendapatkan-daftar-environment-variables-yang-ada","text":"Untuk melihat Environment Variables yang ada, ketikkan printenv di Terminal. Sebagai contoh, di Ubuntu 20.04 unity: [ I ] \u25c6 shell git: ( main ) \u2717 \u276f\u276f\u276f printenv COMPIZ_CONFIG_PROFILE = ubuntu LANG = en_US.UTF-8 CLUTTER_IM_MODULE = ibus GEM_PATH = /home/memet/.rvm/gems/ruby-3.0.3:/home/memet/.rvm/gems/ruby-3.0.3@global DBUS_SESSION_BUS_ADDRESS = unix:path = /run/user/1000/bus GDMSESSION = unity XAUTHORITY = /run/user/1000/gdm/Xauthority LC_PAPER = id_ID.UTF-8 XDG_MENU_PREFIX = gnome- GEM_HOME = /home/memet/.rvm/gems/ruby-3.0.3 rvm_bin_path = /home/memet/.rvm/bin QT4_IM_MODULE = ibus KOTLIN_HOME = /home/memet/.sdkman/candidates/kotlin/current XDG_SESSION_DESKTOP = unity VTE_VERSION = 6003 MY_RUBY_HOME = /home/memet/.rvm/rubies/ruby-3.0.3 .... Dapat dilihat, environment variables yang ada di Ubuntu sangat banyak, beberapa juga berhubungan dengan sistem. Environment Variables pada tiap sistem berbeda-beda!","title":"Mendapatkan Daftar Environment Variables Yang Ada"},{"location":"belajar/shell/enviroment-variable/#environment-variables-sistem","text":"Environment Variables sistem adalah environment variables yang tersedia secara bawaan dari OS yang digunakan. Seperti $HOSTNAME , $USER , $UID , dan lain-lain. Variabel-variabel ini tidak ada di printenv , melainkan dari file sistem, seperti: $HOSTNAME => /etc/hostname . Beberapa variabel terdapat pada file sistem yang tersembunyi.","title":"Environment Variables Sistem"},{"location":"belajar/shell/enviroment-variable/#menambahkan-environment-variables","text":"Anda dapat menambahkan environment variables Anda sendiri sehingga dapat diakses oleh semua proses dalam satu shell. Jalankan perintah: [ I ] \u25c6 shell git: ( main ) \u2717 \u276f\u276f\u276f export namaVariabel = isiVariabel [ I ] \u25c6 shell git: ( main ) \u2717 \u276f\u276f\u276f env | grep namaVariabel namaVariabel = isiVariabel untuk menambah environment variable, dimana namaVariabel merupakan nama dari variabel dan isiVariabeel adalah isi/value dari variabel. export merupakan perintah yang digunakan untuk mengekspor variabel ke dalam environment variables. Perlu diketahui bahwa environment variable yang Anda tambahkan hanya bersifat sementara dan hanya dapat diakses oleh shell yang digunakan. Jika Anda menggunakan shell lain atau membuka ulang shell, maka variabel tersebut akan terhapus/tidak ditemukan.","title":"Menambahkan Environment Variables"},{"location":"belajar/shell/funtions/","text":"Functions \u00b6 Functions adalah merupakan sebuah metode dimana script kode kita disimpan di dalamnya dan bisa kita ambil sebanyak yang kita inginkan. Oke lalu bagaimana dengan struktur dari function di shell scripting , nah seperti inilah strukturnya : function name (){ Command } Oke disini nama function itu ditandai dengan name nah bukti bahwa itu function ditandai dengan kata function , nah ada yang unik dari si shell scripting dimana ketika kita membuat function kita bisa lakukan tanpa kata function di dalam script sehingga kita bisa langsung membuat namanya, contohnya seperti ini nama (){ Command } Loh heh, semudah itukah? enak banget dong, ya itulah enaknya shell scripting dimana kita bisa melakukan sesimple mungkin, lalu bagaimana dengan contohnya? oke kita ambil contoh simpel aja yang pertama itu tentang penentuan nilai lebih besar dengan struktur yang pertama , kedua kita buat contoh tentang bilangan genap dengan struktur yang kedua, oke kita buat contoh pertama function isGt (){ echo -e \"Masukan Angka Pertama: \\c\" read angka1 echo -e \"Masukan Angka Kedua: \\c\" read angka2 if [[ $angka1 -gt $angka2 ]] then echo \"Angka Terbesar : $angka1 \" else echo \"Angka Terbesar : $angka2 \" fi } isGt Oya saya lupa jelaskan untuk memanggil file kalian cukup tulis nama funtionnya saja contoh diatas namanya isGt maka cara manggil function cukup isGt saja, dan outputnya akan seperti ini Masukan Angka Pertama: 10 Masukan Angka Kedua: 20 Angka Terbesar : 20 Next kita buat untuk yang kedua dimana kita membuat dengan looping dan mencari angka genap dengan struktur seperti contoh kedua genap (){ for i in { 1 ..50 } do if (( $i %2 == 0 )) then echo \"Ini adalah Genap : $i \" else echo \"\" fi done } genap Function Variabel \u00b6 Function variabel ialah sebuah functions yang diikuti dengan variabel. Contoh seperti ini function ganjil memiliki variabel isNum dan dia mengikuti dari function yang ada di ganjil . Bagaimana si bang? sepertinya ribet banget, contohnya strukturnya seperti ini variabel = 2 function name (){ Command } name Nah seperti diataslah contohnya dimana si function akan mengambil variabel diatasnya dan dapat mengolah data tersebut didalam functions isNum = 50 function ganjil (){ for (( i = 0 ; i< = isNum ; i++ )) do if (( $i %2 ! = 0 )) then echo \"Angka Ganjil : $i \" else echo fi done } ganjil Function Pass Parameter \u00b6 Oke, function pass parameter ialah merupakan metode function yang diikuti oleh argumen yang kita inginkan, biasanya ketika tidak diikuti argumen function ini akan menjadi error. Lalu bagaimana function pass parameter di shell scripting. Oke sebelum berlanjut, sedikit informasi aja sebenarnya metode ini tidak terlalu berguna ketika di production karena shell scripting sendiri berfungsi untuk membuild sebuah sistem melalui command yang ada function isFunctionPassParameter (){ echo \"Hello $1 \" } isFunctionPassParameter \"Kiyo\" Pertanyaanya, apakah bisa dijalankan dengan dua parameter atau lebih ?. Bisa saja kalian tinggal tambahkan $2 $3 dan seterusnya sebanyak parameter yang kalian inginkan, contohnya seperti ini function isMoreFunctionPassParameter (){ echo \"Namaku $1 $2 \" } isMoreFunctionPassParameter \"Ahmad\" \"Subarjo\" Function Return Value \u00b6 Oke sama dibahasa pemograman lainnya, di shell scripting terdapat return value juga, dimana fungsinya juga sama untuk mengembalikan data yang ada. Namun di shell scripting cara memanggilnya itu unik dengan menggunakan $? , tetapi secara fungsional tetap saja return value ini sama dengan pass parameter dimana jarang ada yang memakainya. Oke untuk contoh return value di function seperti ini function isReturnValue (){ echo \"Hello World\" return 55 } isReturnValue res: $? echo $res Uniknya di shell scripting ini untuk return value harus berupa numeric / angka maka akan error dan menghasilkan pesan return: Kiyo: numeric argument required ketika di running. Oke mungkin untuk return seperti ini aja, next kita bahas function recursive Function Recursive \u00b6 Oke sebelum membahas ke pokok materi kita bahas dulu apa si yang dimaksud dengan recursive . Recursive ialah sebuah metode dimana memanggil sebuah progam ke progam lainnya dengan cara memanggil diri sendiri. Nah sama dengan materi function recursive kali ini dimana terdapat dua function yang salah satu functionnya memanggil function lain, lalu memanggil function itu sendiri. Piye si, kok ruwet banget, oke kita kasih contoh flownya seperti ini function isFunction1 (){ echo \"Hello World\" isFunction2 \"Kiyo\" } function isFunction2 { echo \"Hay my name is $1 \" } isFunction1 Menarik bukan disini isFunction1 menyimpan isFunction2 dan ketika di running manggilnya isFunction1 maka hasilnya dari isFunction1 dan isFunction2 , oke coba kita buat progam pengecekan prime number dimana function dua berperan untuk inputanya function isResult (){ isPrime value = ` factor $isNumber | wc -w ` if [[ $value -eq 2 ]] then echo \" $isNumber bilangan prima\" else echo \" $isNumber bukan bilangan prima\" fi } function isPrime (){ echo -e \"Enter Number : \\c\" read isNumber } isResult Oke mungkin untuk materi recursive function sampai disini saja next kita bahas apa itu local variables Local Variables \u00b6 Local Variables adalah sebuah metode dimana variabel ini hanya bisa diakses oleh lokal saja atau dalam function saja, contohnya semisalnya kita memiliki nama function isName nah di isName ini terdapat sebuah variabel name yang dibuat lokal sehingga yang bisa akses ini adalah function saja. Oke lalu bagaimana contoh dari yang bukan lokal bang, begini contohnya function isName (){ name = $1 echo \"My Name : $name \" } name = \"Dias\" echo \"My Name : $name => Before\" isName Kiyo echo \"My Name : $name => After\" Maka output yang before itu adalah Dias , lalu print Kiyo , dan yang after itu juga Kiyo My Name : Dias => Before My Name : Kiyo My Name : Kiyo => After Oke lalu contoh lokal nya itu bisa ditandai dengan kata local sebelum variabelnya, contoh seperti ini function isName (){ local name = $1 echo \"My Name : $name \" } name = \"Dias\" echo \"My Name : $name => Before\" isName Kiyo echo \"My Name : $name => After\" Maka output yang before itu adalah Dias , lalu print Kiyo , dan yang after itu juga Dias . Kenapa bisa begitu mas? ya karena si variabel name telah di setting local yang dimana hanya bisa diakses dengan function saja My Name : Dias => Before My Name : Kiyo My Name : Dias => After","title":"Funtions"},{"location":"belajar/shell/funtions/#functions","text":"Functions adalah merupakan sebuah metode dimana script kode kita disimpan di dalamnya dan bisa kita ambil sebanyak yang kita inginkan. Oke lalu bagaimana dengan struktur dari function di shell scripting , nah seperti inilah strukturnya : function name (){ Command } Oke disini nama function itu ditandai dengan name nah bukti bahwa itu function ditandai dengan kata function , nah ada yang unik dari si shell scripting dimana ketika kita membuat function kita bisa lakukan tanpa kata function di dalam script sehingga kita bisa langsung membuat namanya, contohnya seperti ini nama (){ Command } Loh heh, semudah itukah? enak banget dong, ya itulah enaknya shell scripting dimana kita bisa melakukan sesimple mungkin, lalu bagaimana dengan contohnya? oke kita ambil contoh simpel aja yang pertama itu tentang penentuan nilai lebih besar dengan struktur yang pertama , kedua kita buat contoh tentang bilangan genap dengan struktur yang kedua, oke kita buat contoh pertama function isGt (){ echo -e \"Masukan Angka Pertama: \\c\" read angka1 echo -e \"Masukan Angka Kedua: \\c\" read angka2 if [[ $angka1 -gt $angka2 ]] then echo \"Angka Terbesar : $angka1 \" else echo \"Angka Terbesar : $angka2 \" fi } isGt Oya saya lupa jelaskan untuk memanggil file kalian cukup tulis nama funtionnya saja contoh diatas namanya isGt maka cara manggil function cukup isGt saja, dan outputnya akan seperti ini Masukan Angka Pertama: 10 Masukan Angka Kedua: 20 Angka Terbesar : 20 Next kita buat untuk yang kedua dimana kita membuat dengan looping dan mencari angka genap dengan struktur seperti contoh kedua genap (){ for i in { 1 ..50 } do if (( $i %2 == 0 )) then echo \"Ini adalah Genap : $i \" else echo \"\" fi done } genap","title":"Functions"},{"location":"belajar/shell/funtions/#function-variabel","text":"Function variabel ialah sebuah functions yang diikuti dengan variabel. Contoh seperti ini function ganjil memiliki variabel isNum dan dia mengikuti dari function yang ada di ganjil . Bagaimana si bang? sepertinya ribet banget, contohnya strukturnya seperti ini variabel = 2 function name (){ Command } name Nah seperti diataslah contohnya dimana si function akan mengambil variabel diatasnya dan dapat mengolah data tersebut didalam functions isNum = 50 function ganjil (){ for (( i = 0 ; i< = isNum ; i++ )) do if (( $i %2 ! = 0 )) then echo \"Angka Ganjil : $i \" else echo fi done } ganjil","title":"Function Variabel"},{"location":"belajar/shell/funtions/#function-pass-parameter","text":"Oke, function pass parameter ialah merupakan metode function yang diikuti oleh argumen yang kita inginkan, biasanya ketika tidak diikuti argumen function ini akan menjadi error. Lalu bagaimana function pass parameter di shell scripting. Oke sebelum berlanjut, sedikit informasi aja sebenarnya metode ini tidak terlalu berguna ketika di production karena shell scripting sendiri berfungsi untuk membuild sebuah sistem melalui command yang ada function isFunctionPassParameter (){ echo \"Hello $1 \" } isFunctionPassParameter \"Kiyo\" Pertanyaanya, apakah bisa dijalankan dengan dua parameter atau lebih ?. Bisa saja kalian tinggal tambahkan $2 $3 dan seterusnya sebanyak parameter yang kalian inginkan, contohnya seperti ini function isMoreFunctionPassParameter (){ echo \"Namaku $1 $2 \" } isMoreFunctionPassParameter \"Ahmad\" \"Subarjo\"","title":"Function Pass Parameter"},{"location":"belajar/shell/funtions/#function-return-value","text":"Oke sama dibahasa pemograman lainnya, di shell scripting terdapat return value juga, dimana fungsinya juga sama untuk mengembalikan data yang ada. Namun di shell scripting cara memanggilnya itu unik dengan menggunakan $? , tetapi secara fungsional tetap saja return value ini sama dengan pass parameter dimana jarang ada yang memakainya. Oke untuk contoh return value di function seperti ini function isReturnValue (){ echo \"Hello World\" return 55 } isReturnValue res: $? echo $res Uniknya di shell scripting ini untuk return value harus berupa numeric / angka maka akan error dan menghasilkan pesan return: Kiyo: numeric argument required ketika di running. Oke mungkin untuk return seperti ini aja, next kita bahas function recursive","title":"Function Return Value"},{"location":"belajar/shell/funtions/#function-recursive","text":"Oke sebelum membahas ke pokok materi kita bahas dulu apa si yang dimaksud dengan recursive . Recursive ialah sebuah metode dimana memanggil sebuah progam ke progam lainnya dengan cara memanggil diri sendiri. Nah sama dengan materi function recursive kali ini dimana terdapat dua function yang salah satu functionnya memanggil function lain, lalu memanggil function itu sendiri. Piye si, kok ruwet banget, oke kita kasih contoh flownya seperti ini function isFunction1 (){ echo \"Hello World\" isFunction2 \"Kiyo\" } function isFunction2 { echo \"Hay my name is $1 \" } isFunction1 Menarik bukan disini isFunction1 menyimpan isFunction2 dan ketika di running manggilnya isFunction1 maka hasilnya dari isFunction1 dan isFunction2 , oke coba kita buat progam pengecekan prime number dimana function dua berperan untuk inputanya function isResult (){ isPrime value = ` factor $isNumber | wc -w ` if [[ $value -eq 2 ]] then echo \" $isNumber bilangan prima\" else echo \" $isNumber bukan bilangan prima\" fi } function isPrime (){ echo -e \"Enter Number : \\c\" read isNumber } isResult Oke mungkin untuk materi recursive function sampai disini saja next kita bahas apa itu local variables","title":"Function Recursive"},{"location":"belajar/shell/funtions/#local-variables","text":"Local Variables adalah sebuah metode dimana variabel ini hanya bisa diakses oleh lokal saja atau dalam function saja, contohnya semisalnya kita memiliki nama function isName nah di isName ini terdapat sebuah variabel name yang dibuat lokal sehingga yang bisa akses ini adalah function saja. Oke lalu bagaimana contoh dari yang bukan lokal bang, begini contohnya function isName (){ name = $1 echo \"My Name : $name \" } name = \"Dias\" echo \"My Name : $name => Before\" isName Kiyo echo \"My Name : $name => After\" Maka output yang before itu adalah Dias , lalu print Kiyo , dan yang after itu juga Kiyo My Name : Dias => Before My Name : Kiyo My Name : Kiyo => After Oke lalu contoh lokal nya itu bisa ditandai dengan kata local sebelum variabelnya, contoh seperti ini function isName (){ local name = $1 echo \"My Name : $name \" } name = \"Dias\" echo \"My Name : $name => Before\" isName Kiyo echo \"My Name : $name => After\" Maka output yang before itu adalah Dias , lalu print Kiyo , dan yang after itu juga Dias . Kenapa bisa begitu mas? ya karena si variabel name telah di setting local yang dimana hanya bisa diakses dengan function saja My Name : Dias => Before My Name : Kiyo My Name : Dias => After","title":"Local Variables"},{"location":"belajar/shell/hello-world/","text":"hello world \u00b6 shell adalah bahasa pemograman yang menerjemahkan bahasa manusia ke bahasa komputer dalam sistem operasi linux / unix. komputer hanya mengerti bahasa biner yaitu 0 dan 1, sehingga diciptakanlah bahasa pemograman yagn memudahkan komnuikasi manusia dan komputer. contoh sederhana hello world dari shell programming # echo merupakan perintah output dari shell scripting echo \"kata\" contoh echo \"hello world\" ini dapat digunakan pada terminal dan bisa juga disimpan dalam file yang berekstensi .sh yang memungkinkn kita akan menjalankannya nanti.","title":"Hello World"},{"location":"belajar/shell/hello-world/#hello-world","text":"shell adalah bahasa pemograman yang menerjemahkan bahasa manusia ke bahasa komputer dalam sistem operasi linux / unix. komputer hanya mengerti bahasa biner yaitu 0 dan 1, sehingga diciptakanlah bahasa pemograman yagn memudahkan komnuikasi manusia dan komputer. contoh sederhana hello world dari shell programming # echo merupakan perintah output dari shell scripting echo \"kata\" contoh echo \"hello world\" ini dapat digunakan pada terminal dan bisa juga disimpan dalam file yang berekstensi .sh yang memungkinkn kita akan menjalankannya nanti.","title":"hello world"},{"location":"belajar/shell/instruksi-logika/","text":"Instruksi logika \u00b6 saat menulis skrip shelll, mungkin ketika kita perlu mengadopsi satu jalur dari dua jalur yang diberikan. jadi, kita perlu menggunakan pernyataan bersyarat yang memungkinkan program anda membuat keputusuan yang benar dan melakukan tindakan yang benar. unix shell mendukung pernyataan bersyarat yang digunakan untuk melakukan tindakan yang berbeda berdasarkan kondisi yang berbeda. kami sekarang akan memahami dua pernyataan pengambalikan keputusan di sini pernyataan if else kasus pernyataan esac Pernyataan if .. fi \u00b6 pernyataan if else adalah pernyataan pengambilan keputusan yang berguna yang dapat digunakan untuk memilih opsi dari serangkain opsi yang diberikan. sintaks if [ ekspresi ] then statemen fi ekspresi shell dievaluasi dalam sintaks di atas. jika nilai yang dihasilkan adalah true . #!/bin/sh a = 10 b = 30 if [ $a == $b ] then echo \"a sama dengan b\" fi if [ $a ! = $b ] then echo \"a tidak sama dengan b\" fi pernyataan if...else...fi adalah bentuk berikutnya dari pernyataan kontrol yang memungkinkan shell untuk mengeksekusi pernyataan dengan cara yang terkontrol dan membuat pilihan yang tepat. if [ ekpresi ] then statemen else statemen else fi #!/bin/sh a = 10 b = 50 if [ $a == $b ] then echo \"a sama dengan b\" else echo \"a tidak sama dengan b\" fi Pernyataan if .. elif .. fi \u00b6 pernyataan if .. eif .. fi adalah bentuk lanjutan dari pernytaan kontrol yang memungkinkan shell membuat keputusan yang benar dari beberapa kondisi. if [ ekspresi ] then statement elif [ ekspresi ] then statement else statement fi Contoh a = 10 b = 60 if [ $a == $b ] then echo \"a sama dengan b\" elif [ $a -gt $b ] then echo \"a lebih besar dari b\" elif [ $a -lt $b ] then echo \"a lebih kecil dari b\" else echo \"ketiga kondisi tidak terpenhui\" fi Pernyataan esac \u00b6 kita dapat menggunakan beberapa pernyataan if ... elif untuk melakukan cabang multiway. Namun, ini tidak selalu merupakan solusi terbaik, terutama ketika semua cabang bergantung pada nilai satu variabel. shell mendukugn pernyaataan case ... esac yang menangani situasi ini dengan tepat, dan melakukannya lebih efisisien daripada pernyataan if ... elif berulang. sintaks dasar dari pernyataan case ... esac adalah memberikan ekspresi untuk mengevaluasi dan mengeksekusi beberapa pernyataan berbeda berdasarkan nilai ekspresi. interpreter memerikssa setiap kasus terhadap nilai ekspresi sampai ditemukan kecocokan. jika tidak ada yang cocok, kondisi default akan digunakan. case kata in pattern1 ) statement pattern2 ) statement pattern3 ) statement * ) default statement esac penggunaan yang baik untuk pernyataan kasus adalah evaluasi argumen baris perintah sebagi berikut. #!/bin/bash buah = \"kiwi\" case $buah in \"apel\" ) echo \"apel adalah buah paling enak\" ;; \"pisang\" ) echo \"saya menyukai pisang\" ;; \"kiwi\" ) echo \"kiwi adalah buah paling enak\" ;; esac","title":"Instruksi Logika"},{"location":"belajar/shell/instruksi-logika/#instruksi-logika","text":"saat menulis skrip shelll, mungkin ketika kita perlu mengadopsi satu jalur dari dua jalur yang diberikan. jadi, kita perlu menggunakan pernyataan bersyarat yang memungkinkan program anda membuat keputusuan yang benar dan melakukan tindakan yang benar. unix shell mendukung pernyataan bersyarat yang digunakan untuk melakukan tindakan yang berbeda berdasarkan kondisi yang berbeda. kami sekarang akan memahami dua pernyataan pengambalikan keputusan di sini pernyataan if else kasus pernyataan esac","title":"Instruksi logika"},{"location":"belajar/shell/instruksi-logika/#pernyataan-if-fi","text":"pernyataan if else adalah pernyataan pengambilan keputusan yang berguna yang dapat digunakan untuk memilih opsi dari serangkain opsi yang diberikan. sintaks if [ ekspresi ] then statemen fi ekspresi shell dievaluasi dalam sintaks di atas. jika nilai yang dihasilkan adalah true . #!/bin/sh a = 10 b = 30 if [ $a == $b ] then echo \"a sama dengan b\" fi if [ $a ! = $b ] then echo \"a tidak sama dengan b\" fi pernyataan if...else...fi adalah bentuk berikutnya dari pernyataan kontrol yang memungkinkan shell untuk mengeksekusi pernyataan dengan cara yang terkontrol dan membuat pilihan yang tepat. if [ ekpresi ] then statemen else statemen else fi #!/bin/sh a = 10 b = 50 if [ $a == $b ] then echo \"a sama dengan b\" else echo \"a tidak sama dengan b\" fi","title":"Pernyataan if .. fi"},{"location":"belajar/shell/instruksi-logika/#pernyataan-if-elif-fi","text":"pernyataan if .. eif .. fi adalah bentuk lanjutan dari pernytaan kontrol yang memungkinkan shell membuat keputusan yang benar dari beberapa kondisi. if [ ekspresi ] then statement elif [ ekspresi ] then statement else statement fi Contoh a = 10 b = 60 if [ $a == $b ] then echo \"a sama dengan b\" elif [ $a -gt $b ] then echo \"a lebih besar dari b\" elif [ $a -lt $b ] then echo \"a lebih kecil dari b\" else echo \"ketiga kondisi tidak terpenhui\" fi","title":"Pernyataan if .. elif .. fi"},{"location":"belajar/shell/instruksi-logika/#pernyataan-esac","text":"kita dapat menggunakan beberapa pernyataan if ... elif untuk melakukan cabang multiway. Namun, ini tidak selalu merupakan solusi terbaik, terutama ketika semua cabang bergantung pada nilai satu variabel. shell mendukugn pernyaataan case ... esac yang menangani situasi ini dengan tepat, dan melakukannya lebih efisisien daripada pernyataan if ... elif berulang. sintaks dasar dari pernyataan case ... esac adalah memberikan ekspresi untuk mengevaluasi dan mengeksekusi beberapa pernyataan berbeda berdasarkan nilai ekspresi. interpreter memerikssa setiap kasus terhadap nilai ekspresi sampai ditemukan kecocokan. jika tidak ada yang cocok, kondisi default akan digunakan. case kata in pattern1 ) statement pattern2 ) statement pattern3 ) statement * ) default statement esac penggunaan yang baik untuk pernyataan kasus adalah evaluasi argumen baris perintah sebagi berikut. #!/bin/bash buah = \"kiwi\" case $buah in \"apel\" ) echo \"apel adalah buah paling enak\" ;; \"pisang\" ) echo \"saya menyukai pisang\" ;; \"kiwi\" ) echo \"kiwi adalah buah paling enak\" ;; esac","title":"Pernyataan esac"},{"location":"belajar/shell/izin-file/","text":"Permission File \u00b6 Oke masih mengenai tentang file, sebelum itu apa si yang dimaksud dengan permission file ? . Permission file ialah metode dimana untuk mengelola hak akses dari sebuah file. Untuk mengubah permission file itu sendiri dengan command chmod , contoh yang kita lakukan pada pembelajaran hari ini kita sering melakukan chmod 777 . Lalu yang dimaksud angka 777 ? Apakah kode rahasia? Atau apa?, Sebelum itu kita pernah menemukan hal seperti ini ketika melihat isi directory [I] \u25c6 shell git:(main) \u2717 \u276f\u276f\u276f ls -la total 84 drwxrwxr-x 2 memet memet 4096 Sep 23 14:12 ./ drwxrwxr-x 4 memet memet 4096 Sep 15 14:35 ../ -rw-rw-r-- 1 memet memet 5166 Sep 23 06:39 array.md -rw-rw-r-- 1 memet memet 2228 Sep 15 22:07 bc-command.md -rw-rw-r-- 1 memet memet 732 Sep 23 06:48 break.md -rw-rw-r-- 1 memet memet 1110 Sep 23 06:49 continue.md -rw-rw-r-- 1 memet memet 3061 Sep 23 14:01 enviroment-variable.md -rw-rw-r-- 1 memet memet 6933 Sep 23 06:53 funtions.md -rw-rw-r-- 1 memet memet 666 Sep 15 14:55 hello-world.md -rw-rw-r-- 1 memet memet 1647 Sep 15 14:47 index.md -rw-rw-r-- 1 memet memet 3125 Sep 15 22:16 instruksi-logika.md -rw-rw-r-- 1 memet memet 0 Sep 23 14:12 izin_file.md -rw-rw-r-- 1 memet memet 3854 Sep 23 06:45 loops.md -rw-rw-r-- 1 memet memet 1703 Sep 15 21:47 operasi-aritmatika.md -rw-rw-r-- 1 memet memet 1110 Sep 23 14:05 operasi-file.md -rw-rw-r-- 1 memet memet 913 Sep 23 14:06 operasi-folder.md -rw-rw-r-- 1 memet memet 2803 Sep 15 16:00 operator.md -rw-rw-r-- 1 memet memet 1349 Sep 16 02:29 user-input.md -rw-rw-r-- 1 memet memet 2385 Sep 15 14:59 variabel.md -rw-rw-r-- 1 memet memet 1831 Sep 15 15:04 variabel-spesial.md Mungkin kita awali dengan stepnya , maksudnya step itu bagaimana? Mungkin bisa disebut user, permission file juga melibatkan beberapa user dalam melakukannya, kita ambil contoh file test.sh Symbol Deskripsi -rwx Oke ini untuk permission untuk user r-x Ini permission untuk group r-x Ini permission untuk other Loh heh penjelasanya bagaimana? untuk penjelasana apa itu -rwx, r-x kalian bisa melihat penjelasan dibawah ini, kalian bisa mengetahui apa yang dimaksud -rwx, r-x dan chmod apa yang digunakan Symbol Deskripsi r Akses yang digunakan untuk membaca saja w Diberi akses untuk mengubah isi file x Permission untuk meng-eksekusi file - Tidak mendapatkan akses apapun d Tipenya merupakan folder / directory Dari tabel diatas menjelaskan bahwa setiap permission yang kita lakukan memiliki alur yang berbeda, ada yang memberikan akses keseluruhan dan ada juga yang hanya membaca saja. Lalu bagaimana kita mengetahuinya, bahwa akses itu hanya digunakan untuk membaca saja. Oke lihat tabel berikut ini Nomor Permission Type Symbol 0 No Permission - 1 Execute -x 2 Write -w 3 Execute + Write -wx 4 Read r- 5 Read + Execute r-x 6 Read + Write rw- 7 Read + Write + Execute rwx Dari sini kita tahu bahwa setiap file yang di permission chmod 777 maka akan mendapatkan kesluruhan akses , baik membaca, write, dan execute. Oke lalu bagaimana dengan yang chmod +x , chown , dan sebagainya. Next kita bahas di folder lainnya. Contoh Progam \u00b6 Oke kita sudah tahu bahwa setiap file memiliki permission dan alur yang berbeda, nah kali ini kita akan mencoba membuat sebuah progam dengan shell scripting dimana progam ini akan chmod sebuah file yang kita input / panggil. Bagaimana kah itu?, oke disini mungkin sekalian mereview materi basic kembali, progam yang kita pakai ada bberapa metode, mulai dari Function + Input User + If Statement + Pemanggilan File . Oya untuk chmodnya kita gunakan sesuai dengan inputan user, seperti inilah contohnya #!/bin/bash permission_file (){ echo -e \"Masukan File : \\c\" read file_name if [[ -f $file_name ]] then echo \"Permission (ex. 777): \" read permissions chmod $permissions $file_name else echo \"Not Found\" fi } permission_file","title":"Izin File"},{"location":"belajar/shell/izin-file/#permission-file","text":"Oke masih mengenai tentang file, sebelum itu apa si yang dimaksud dengan permission file ? . Permission file ialah metode dimana untuk mengelola hak akses dari sebuah file. Untuk mengubah permission file itu sendiri dengan command chmod , contoh yang kita lakukan pada pembelajaran hari ini kita sering melakukan chmod 777 . Lalu yang dimaksud angka 777 ? Apakah kode rahasia? Atau apa?, Sebelum itu kita pernah menemukan hal seperti ini ketika melihat isi directory [I] \u25c6 shell git:(main) \u2717 \u276f\u276f\u276f ls -la total 84 drwxrwxr-x 2 memet memet 4096 Sep 23 14:12 ./ drwxrwxr-x 4 memet memet 4096 Sep 15 14:35 ../ -rw-rw-r-- 1 memet memet 5166 Sep 23 06:39 array.md -rw-rw-r-- 1 memet memet 2228 Sep 15 22:07 bc-command.md -rw-rw-r-- 1 memet memet 732 Sep 23 06:48 break.md -rw-rw-r-- 1 memet memet 1110 Sep 23 06:49 continue.md -rw-rw-r-- 1 memet memet 3061 Sep 23 14:01 enviroment-variable.md -rw-rw-r-- 1 memet memet 6933 Sep 23 06:53 funtions.md -rw-rw-r-- 1 memet memet 666 Sep 15 14:55 hello-world.md -rw-rw-r-- 1 memet memet 1647 Sep 15 14:47 index.md -rw-rw-r-- 1 memet memet 3125 Sep 15 22:16 instruksi-logika.md -rw-rw-r-- 1 memet memet 0 Sep 23 14:12 izin_file.md -rw-rw-r-- 1 memet memet 3854 Sep 23 06:45 loops.md -rw-rw-r-- 1 memet memet 1703 Sep 15 21:47 operasi-aritmatika.md -rw-rw-r-- 1 memet memet 1110 Sep 23 14:05 operasi-file.md -rw-rw-r-- 1 memet memet 913 Sep 23 14:06 operasi-folder.md -rw-rw-r-- 1 memet memet 2803 Sep 15 16:00 operator.md -rw-rw-r-- 1 memet memet 1349 Sep 16 02:29 user-input.md -rw-rw-r-- 1 memet memet 2385 Sep 15 14:59 variabel.md -rw-rw-r-- 1 memet memet 1831 Sep 15 15:04 variabel-spesial.md Mungkin kita awali dengan stepnya , maksudnya step itu bagaimana? Mungkin bisa disebut user, permission file juga melibatkan beberapa user dalam melakukannya, kita ambil contoh file test.sh Symbol Deskripsi -rwx Oke ini untuk permission untuk user r-x Ini permission untuk group r-x Ini permission untuk other Loh heh penjelasanya bagaimana? untuk penjelasana apa itu -rwx, r-x kalian bisa melihat penjelasan dibawah ini, kalian bisa mengetahui apa yang dimaksud -rwx, r-x dan chmod apa yang digunakan Symbol Deskripsi r Akses yang digunakan untuk membaca saja w Diberi akses untuk mengubah isi file x Permission untuk meng-eksekusi file - Tidak mendapatkan akses apapun d Tipenya merupakan folder / directory Dari tabel diatas menjelaskan bahwa setiap permission yang kita lakukan memiliki alur yang berbeda, ada yang memberikan akses keseluruhan dan ada juga yang hanya membaca saja. Lalu bagaimana kita mengetahuinya, bahwa akses itu hanya digunakan untuk membaca saja. Oke lihat tabel berikut ini Nomor Permission Type Symbol 0 No Permission - 1 Execute -x 2 Write -w 3 Execute + Write -wx 4 Read r- 5 Read + Execute r-x 6 Read + Write rw- 7 Read + Write + Execute rwx Dari sini kita tahu bahwa setiap file yang di permission chmod 777 maka akan mendapatkan kesluruhan akses , baik membaca, write, dan execute. Oke lalu bagaimana dengan yang chmod +x , chown , dan sebagainya. Next kita bahas di folder lainnya.","title":"Permission File"},{"location":"belajar/shell/izin-file/#contoh-progam","text":"Oke kita sudah tahu bahwa setiap file memiliki permission dan alur yang berbeda, nah kali ini kita akan mencoba membuat sebuah progam dengan shell scripting dimana progam ini akan chmod sebuah file yang kita input / panggil. Bagaimana kah itu?, oke disini mungkin sekalian mereview materi basic kembali, progam yang kita pakai ada bberapa metode, mulai dari Function + Input User + If Statement + Pemanggilan File . Oya untuk chmodnya kita gunakan sesuai dengan inputan user, seperti inilah contohnya #!/bin/bash permission_file (){ echo -e \"Masukan File : \\c\" read file_name if [[ -f $file_name ]] then echo \"Permission (ex. 777): \" read permissions chmod $permissions $file_name else echo \"Not Found\" fi } permission_file","title":"Contoh Progam"},{"location":"belajar/shell/loops/","text":"Apa itu Loop? \u00b6 Loop atau biasa disebutkan dengan perulangan ialah dimana sebuah metode yang akan melakukan perulangan hingga datanya itu bernilai True . Didalam loop shell scripting itu terdapat beberapa jenis For Loop => Ialah control flow untuk menentukan iterasi, yang memungkinkan kode dieksekusi berulang kali. While Loop => Melakukan perulangan selagi data bernilai true Until Loop => Melakukan perulangan yang mengikuti dari CommandEnd nya Oke mari kita bahas satu satu , apa itu for loop , while loop , dan until loop For Loop \u00b6 For loop ialah sebuah perulangan yang telah dilakukan iterasi dimana didalamnya telah dikasih kondisi sebanyak melakukannya perulangan. For loop salah satu perulangan yang mudah dibaca alurnya ketimbang perulangan yang lainnya. Oke terus bagaimana struktur dari for loop , strukturnya itu mudah seperti ini for VARIABEL in CONDITION do COMMAND1 COMMAND2 done Lalu bagaimana contonya ? oke kita akan dari yang mudah terlebih dahulu for i in 1 2 3 4 5 do echo \"Result is : $i \" done Salah satu contohnya seperti diatas, namun itu kurang efisiensi, coba kita berpikir lebih jauh semisalnya kita ingin menampilkan data lebih dari 100 bagaimana? apakah dengan sepeerti itu? sudah tentu tidak kita menggunakan format {START..END} seperti apa tuh, contohnya for i in { 1 ..5 } do echo \"Result is : $i \" done Ada lagi semisalnya kita ingin bahwa angka START dinaikan dengan angka yang kita tentukan, bagaimana caranya? dengan menggunakan {START..END..INCREMENT} dimana setiap angka akan ditambahkan dengan angka INCREMENT dan akan berakhir sesuai nilai END contohnya for i in { 0 ..5..2 } do echo \" $i \" done Output 2 4 Nah diatas contoh menggunakan angka. Nah uniknya di for loop ini kita bisa melakukan berupa data file , ataupun data array , mari kita contoh dengan data array buah =( 'apel' 'anggur' 'pir' ) for i in ${ buah [@] } do echo \" $i \" done Output: apel anggur pir Until Loop \u00b6 Until looop ialah sebuah perulangan dimana akan kondisinya ini keterbalikan dari si while loop . Loh maksudnya gimana nih? Maksudnya gini di while loop itu kita harus mencari cara bagaimana caranya akan menghasilkan angka yang ditentukan untuk berhentinya loop Nah until loop ini dimana dia akan berhenti bedasarkan kondisinya itu kurang dari hasil si datanya. Semisalnya begini kita ingin print angka 1-15 , dengan until loop. Nah kondisi yang dipakai itu $var > 15 bukanlah $var <= 15 . Loh heh, ko begitu ? menarik bukan, mari kita bahas strukturnya until (( conditions )) do command1 command2 ... .... commandEnd done Jadi untuk loopingnya berhenti itu ada didalam CommandEnd dimana semisalnya kita ingin membuat angka 1-15 maka harus var++ supaya loopnya berhenti jika tidak maka akan terjadi infinite loop num = 1 until (( $num > 15 )) do echo \"Result Is : $num \" (( num++ )) done While Loop \u00b6 While loop ialah sebuah perulangan yang dimana akan terus melakukannya selagi bernilai true. Lalu strukturnya bagaimana? Strukturnya itu mudah banget, seperti ini while (( conditions )) do command1 command2 command3 done Nah lalu bagaimana contohnya?, oke mari kita buat sebuah keadaan sederhana dimana si num defaultnya adalah 1 , disini kita ingin menampilkan setiap angka dari si num dengan syarat hanya sampai angka 15 saja, bagaimana progamnya?. Sperti ini num = 1 while (( $num < = 15 )) do echo \"Index Of $num \" (( num++ )) done Maka outputnya itu Index Of : num sampai num sama dengan 15 maka akan berhenti looping. Oya alasan ditambahkan num++ agar nilainya bertambah jika tidak maka akan menjadi infinite loop","title":"Loops"},{"location":"belajar/shell/loops/#apa-itu-loop","text":"Loop atau biasa disebutkan dengan perulangan ialah dimana sebuah metode yang akan melakukan perulangan hingga datanya itu bernilai True . Didalam loop shell scripting itu terdapat beberapa jenis For Loop => Ialah control flow untuk menentukan iterasi, yang memungkinkan kode dieksekusi berulang kali. While Loop => Melakukan perulangan selagi data bernilai true Until Loop => Melakukan perulangan yang mengikuti dari CommandEnd nya Oke mari kita bahas satu satu , apa itu for loop , while loop , dan until loop","title":"Apa itu Loop?"},{"location":"belajar/shell/loops/#for-loop","text":"For loop ialah sebuah perulangan yang telah dilakukan iterasi dimana didalamnya telah dikasih kondisi sebanyak melakukannya perulangan. For loop salah satu perulangan yang mudah dibaca alurnya ketimbang perulangan yang lainnya. Oke terus bagaimana struktur dari for loop , strukturnya itu mudah seperti ini for VARIABEL in CONDITION do COMMAND1 COMMAND2 done Lalu bagaimana contonya ? oke kita akan dari yang mudah terlebih dahulu for i in 1 2 3 4 5 do echo \"Result is : $i \" done Salah satu contohnya seperti diatas, namun itu kurang efisiensi, coba kita berpikir lebih jauh semisalnya kita ingin menampilkan data lebih dari 100 bagaimana? apakah dengan sepeerti itu? sudah tentu tidak kita menggunakan format {START..END} seperti apa tuh, contohnya for i in { 1 ..5 } do echo \"Result is : $i \" done Ada lagi semisalnya kita ingin bahwa angka START dinaikan dengan angka yang kita tentukan, bagaimana caranya? dengan menggunakan {START..END..INCREMENT} dimana setiap angka akan ditambahkan dengan angka INCREMENT dan akan berakhir sesuai nilai END contohnya for i in { 0 ..5..2 } do echo \" $i \" done Output 2 4 Nah diatas contoh menggunakan angka. Nah uniknya di for loop ini kita bisa melakukan berupa data file , ataupun data array , mari kita contoh dengan data array buah =( 'apel' 'anggur' 'pir' ) for i in ${ buah [@] } do echo \" $i \" done Output: apel anggur pir","title":"For Loop"},{"location":"belajar/shell/loops/#until-loop","text":"Until looop ialah sebuah perulangan dimana akan kondisinya ini keterbalikan dari si while loop . Loh maksudnya gimana nih? Maksudnya gini di while loop itu kita harus mencari cara bagaimana caranya akan menghasilkan angka yang ditentukan untuk berhentinya loop Nah until loop ini dimana dia akan berhenti bedasarkan kondisinya itu kurang dari hasil si datanya. Semisalnya begini kita ingin print angka 1-15 , dengan until loop. Nah kondisi yang dipakai itu $var > 15 bukanlah $var <= 15 . Loh heh, ko begitu ? menarik bukan, mari kita bahas strukturnya until (( conditions )) do command1 command2 ... .... commandEnd done Jadi untuk loopingnya berhenti itu ada didalam CommandEnd dimana semisalnya kita ingin membuat angka 1-15 maka harus var++ supaya loopnya berhenti jika tidak maka akan terjadi infinite loop num = 1 until (( $num > 15 )) do echo \"Result Is : $num \" (( num++ )) done","title":"Until Loop"},{"location":"belajar/shell/loops/#while-loop","text":"While loop ialah sebuah perulangan yang dimana akan terus melakukannya selagi bernilai true. Lalu strukturnya bagaimana? Strukturnya itu mudah banget, seperti ini while (( conditions )) do command1 command2 command3 done Nah lalu bagaimana contohnya?, oke mari kita buat sebuah keadaan sederhana dimana si num defaultnya adalah 1 , disini kita ingin menampilkan setiap angka dari si num dengan syarat hanya sampai angka 15 saja, bagaimana progamnya?. Sperti ini num = 1 while (( $num < = 15 )) do echo \"Index Of $num \" (( num++ )) done Maka outputnya itu Index Of : num sampai num sama dengan 15 maka akan berhenti looping. Oya alasan ditambahkan num++ agar nilainya bertambah jika tidak maka akan menjadi infinite loop","title":"While Loop"},{"location":"belajar/shell/operasi-aritmatika/","text":"Operasi aritmatika \u00b6 Perform Arimathic Operations ialah sebuah metode dimana memanipulasi operasi aritmatika yang menggunakan tanda $ untuk melakukan operasi. Lalu bagaimana formatnya om? Okey, formatnya tuh seperti ini variabel1 = number variabel2 = number echo $(( variabel1 + variabel2 )) echo $(( variabel1 - variabel2 )) echo $(( variabel1 / variabel2 )) echo $(( variabel1 * variabel2 )) Jadi tanda $ menandakan bahwa yang kita masukkan itu adalah sebuah variabel, bukanlah sebuah string ataupun angka. Oke, lalu bagaimana contohnya? Seperti ini contohnya variabel1 = 20 variabel2 = 15 echo $(( variabel1 + variabel2 )) echo $(( variabel1 - variabel2 )) echo $(( variabel1 / variabel2 )) echo $(( variabel1 * variabel2 )) Output : 35 5 1 300 Namun ada lagi selain dari $ ada namanya expr dimana fungsi nya itu sebagai mengekspresikan output dari nilai value, yang dimana ekspresi yang dimaksud ini antara lain pertambahan, pengurangan, pembagian dan perkalian. Formatnya seperti ini variabel1 = number variabel2 = number echo $( expr $variabel1 + $variabel2 ) echo $( expr $variabel1 - $variabel2 ) echo $( expr $variabel1 \\* $variabel2 ) echo $( expr $variabel1 / $variabel2 ) Eits sebentar kenapa yang operasi perkalian dijadikan seperti ini \\* , jadi pada method expr sendiri ini operasi perkalian menggunakan arimethic expression yaitu dengan tanda backslash. Contohnya seperti ini variabel1 = 20 variabel2 = 15 echo $( expr $variabel1 + $variabel2 ) echo $( expr $variabel1 - $variabel2 ) echo $( expr $variabel1 \\* $variabel2 ) echo $( expr $variabel1 / $variabel2 ) Output : 35 5 300 1","title":"Operasi Aritmatika"},{"location":"belajar/shell/operasi-aritmatika/#operasi-aritmatika","text":"Perform Arimathic Operations ialah sebuah metode dimana memanipulasi operasi aritmatika yang menggunakan tanda $ untuk melakukan operasi. Lalu bagaimana formatnya om? Okey, formatnya tuh seperti ini variabel1 = number variabel2 = number echo $(( variabel1 + variabel2 )) echo $(( variabel1 - variabel2 )) echo $(( variabel1 / variabel2 )) echo $(( variabel1 * variabel2 )) Jadi tanda $ menandakan bahwa yang kita masukkan itu adalah sebuah variabel, bukanlah sebuah string ataupun angka. Oke, lalu bagaimana contohnya? Seperti ini contohnya variabel1 = 20 variabel2 = 15 echo $(( variabel1 + variabel2 )) echo $(( variabel1 - variabel2 )) echo $(( variabel1 / variabel2 )) echo $(( variabel1 * variabel2 )) Output : 35 5 1 300 Namun ada lagi selain dari $ ada namanya expr dimana fungsi nya itu sebagai mengekspresikan output dari nilai value, yang dimana ekspresi yang dimaksud ini antara lain pertambahan, pengurangan, pembagian dan perkalian. Formatnya seperti ini variabel1 = number variabel2 = number echo $( expr $variabel1 + $variabel2 ) echo $( expr $variabel1 - $variabel2 ) echo $( expr $variabel1 \\* $variabel2 ) echo $( expr $variabel1 / $variabel2 ) Eits sebentar kenapa yang operasi perkalian dijadikan seperti ini \\* , jadi pada method expr sendiri ini operasi perkalian menggunakan arimethic expression yaitu dengan tanda backslash. Contohnya seperti ini variabel1 = 20 variabel2 = 15 echo $( expr $variabel1 + $variabel2 ) echo $( expr $variabel1 - $variabel2 ) echo $( expr $variabel1 \\* $variabel2 ) echo $( expr $variabel1 / $variabel2 ) Output : 35 5 300 1","title":"Operasi aritmatika"},{"location":"belajar/shell/operasi-file/","text":"Operation File \u00b6 Oke sebentar yang dimaksud dengan operation file itu bagaimana?, pertanyaan yang bagus mari kita bahas tuntas. Operasi file yang dimaksud ialah dimana kita akan membaca file, dan membuktikan adanya sebuah file dengan shell scripting. Nah lalu bagaimana untuk mengambil file dari luar, bisa dilakukan dengan $1 , jadi akan seperti ini variabel = $1 cat $variabel Oke cat itu apa ? apakah itu kucing?. Bukan bree, beda cerita cat yang dimaksud disini ialah command dasar linux yang digunakan untuk membaca isi file . Oke mungkin penjelasan detail cat akan dibahas di usefull_command yang penting kita sudah tau bahwa cat itu untuk membaca file. Next bagaimana caranya kita tahu bahwa file itu ada ?. Hal ini bisa dilakukan dengan -f , bagaimana tuh? seperti ini echo -e \"Enter your file : \\c\" read variabel if [[ -f $variabel ]] then echo \"File Found\" else echo \"Not Found\" fi Oke untuk file kita udah tau nih caranya bagaimana, lalu bagaimana dengan folder? mari kita bahas","title":"Operasi File"},{"location":"belajar/shell/operasi-file/#operation-file","text":"Oke sebentar yang dimaksud dengan operation file itu bagaimana?, pertanyaan yang bagus mari kita bahas tuntas. Operasi file yang dimaksud ialah dimana kita akan membaca file, dan membuktikan adanya sebuah file dengan shell scripting. Nah lalu bagaimana untuk mengambil file dari luar, bisa dilakukan dengan $1 , jadi akan seperti ini variabel = $1 cat $variabel Oke cat itu apa ? apakah itu kucing?. Bukan bree, beda cerita cat yang dimaksud disini ialah command dasar linux yang digunakan untuk membaca isi file . Oke mungkin penjelasan detail cat akan dibahas di usefull_command yang penting kita sudah tau bahwa cat itu untuk membaca file. Next bagaimana caranya kita tahu bahwa file itu ada ?. Hal ini bisa dilakukan dengan -f , bagaimana tuh? seperti ini echo -e \"Enter your file : \\c\" read variabel if [[ -f $variabel ]] then echo \"File Found\" else echo \"Not Found\" fi Oke untuk file kita udah tau nih caranya bagaimana, lalu bagaimana dengan folder? mari kita bahas","title":"Operation File"},{"location":"belajar/shell/operasi-folder/","text":"Operation Folder \u00b6 Operation folder dimana kita memanggil folder dari komputer kita. Sebelum itu mari kita bahas, apa itu mkdir ?. Oke mkdir ialah command linux yang digunakan untuk membuat sebuah folder. Untuk penjelasan lebih detail kita akan bahas di usefull_command yang penting kita tau bahwa mkdir command untuk buat folder. variabel = $1 mkdir $variabel Lalu bagaimana cara check bahwa directory sudah ada ? dengan -d dimaan fungsinya ini untuk mengecheck adakah directory yang kita masukan, untuk contoh progamnya seperti ini echo -e \"Enter Directory : \\c\" read folder_name if [[ -d $folder_name ]] then echo \"Folder Found\" else echo \"Folder Not Found\" fi Jadi logicnya ketika folder itu ada, maka menghasilkan output Folder Found dan jika tidak outputnya adalah Folder Not Found","title":"Operasi Folder"},{"location":"belajar/shell/operasi-folder/#operation-folder","text":"Operation folder dimana kita memanggil folder dari komputer kita. Sebelum itu mari kita bahas, apa itu mkdir ?. Oke mkdir ialah command linux yang digunakan untuk membuat sebuah folder. Untuk penjelasan lebih detail kita akan bahas di usefull_command yang penting kita tau bahwa mkdir command untuk buat folder. variabel = $1 mkdir $variabel Lalu bagaimana cara check bahwa directory sudah ada ? dengan -d dimaan fungsinya ini untuk mengecheck adakah directory yang kita masukan, untuk contoh progamnya seperti ini echo -e \"Enter Directory : \\c\" read folder_name if [[ -d $folder_name ]] then echo \"Folder Found\" else echo \"Folder Not Found\" fi Jadi logicnya ketika folder itu ada, maka menghasilkan output Folder Found dan jika tidak outputnya adalah Folder Not Found","title":"Operation Folder"},{"location":"belajar/shell/operator/","text":"operator \u00b6 ada berbagai operator yang didukung oleh setiap shell antara lain operator aritmatika operator relasional operator boolean Aritmatika \u00b6 Bourne shell awalnya tidak memiliki mekanisme untuk melakukan operasi aritmatika sederhana tetapi menggunakan program eksternal, baik awk atau expr . contoh operator aritmatikan antara lain yaitu penambahan ( + ) pengurangan ( - ) perkalian ( * ) pembagian ( \\ ) modulus ( % ) contoh #!/usr/bin/bash penjumlahan = ` expr 2 + 2 ` pengurangan = ` expr 5 - 3 ` perkalian = ` expr 3 * 4 ` pembagian = ` expr 6 / 2 ` echo \"Hasil penjumlahan 2 + 2 = $penjumlahan \" echo \"Hasil pengurangan 5 - 3 = $pengurangan \" echo \"Hasil perkalian 3 * 4 = $perkalian \" echo \"Hasil pembagian 6 / 2 = $pembagian \" Relasional \u00b6 Bourne Shell mendukung operator relasional berikut yang khusus untuk nilai numerik. Operator ini tidak bekerja untuk nilai string kecuali nilainya numerik. Misalnya, operator berikut akan bekerja untuk memeriksa hubungan antara 10 dan 20 serta di antara \"10\" dan \"20\" tetapi tidak di antara \"sepuluh\" dan \"dua puluh\". Operator Desktipsi Contoh -eq memeriksa apakah nilai dua operan sama atau tidak;, jika ya, maka kondisinya menjadi benar [ $a -eq $b ] tidak benar. -ne memeriksa apakah nilai dua opran sama atau tidak; jika nilainya tidak sama, maka kondisinya menjadi benar. [ $a -ne $b ] benar. -gt memeriksa apakah nilai operan kiri lebih besar dari nilai operan kanan; jika ya, maka kondisinya menjadi benar. [ $a -gt $b ] tidak benar. -lt memeriksa apakah nilai operan kiri kurang dari nilai operan kanan; jika ya, maka kondisinya menjadi benar. [ $a -lt $b ] benar. -ge memeriksa apakah nilai operan kiri lebih besar atau sama dengan niai operan kanan jika ya, maka kondisinya menjadi benar. [ $a -ge $b ] tidak benar. -le memeriksa apakah nilai operan kiri kurang dari atau sama dengan nilai operan kanan; jika ya, maka kondisinya menjadi benar. [ $a -le $b ] benar. Boolean \u00b6 Operator Boolean berikut ini didukung oleh Bourne Shell. Asumsikan variabel a menampung 5 dan variabel b menampung 3- maka Operator Deskripsi Contoh ! ini adalaha negasi logis. ini membalikkan kondisi benar menjadi salah dan sebaliknya [!false] benar o ini logis atau . jika salah satu operan benar, maka kondisinya menjadi benar. [$a -lt 20 -o $b -gt 100] benar a ini adalah logis dan . jika kedua operan benar, makan kondisi menjadi benar dan jika tidak salah [$a -lt 20 -a $b -gt 100] salah","title":"Operator"},{"location":"belajar/shell/operator/#operator","text":"ada berbagai operator yang didukung oleh setiap shell antara lain operator aritmatika operator relasional operator boolean","title":"operator"},{"location":"belajar/shell/operator/#aritmatika","text":"Bourne shell awalnya tidak memiliki mekanisme untuk melakukan operasi aritmatika sederhana tetapi menggunakan program eksternal, baik awk atau expr . contoh operator aritmatikan antara lain yaitu penambahan ( + ) pengurangan ( - ) perkalian ( * ) pembagian ( \\ ) modulus ( % ) contoh #!/usr/bin/bash penjumlahan = ` expr 2 + 2 ` pengurangan = ` expr 5 - 3 ` perkalian = ` expr 3 * 4 ` pembagian = ` expr 6 / 2 ` echo \"Hasil penjumlahan 2 + 2 = $penjumlahan \" echo \"Hasil pengurangan 5 - 3 = $pengurangan \" echo \"Hasil perkalian 3 * 4 = $perkalian \" echo \"Hasil pembagian 6 / 2 = $pembagian \"","title":"Aritmatika"},{"location":"belajar/shell/operator/#relasional","text":"Bourne Shell mendukung operator relasional berikut yang khusus untuk nilai numerik. Operator ini tidak bekerja untuk nilai string kecuali nilainya numerik. Misalnya, operator berikut akan bekerja untuk memeriksa hubungan antara 10 dan 20 serta di antara \"10\" dan \"20\" tetapi tidak di antara \"sepuluh\" dan \"dua puluh\". Operator Desktipsi Contoh -eq memeriksa apakah nilai dua operan sama atau tidak;, jika ya, maka kondisinya menjadi benar [ $a -eq $b ] tidak benar. -ne memeriksa apakah nilai dua opran sama atau tidak; jika nilainya tidak sama, maka kondisinya menjadi benar. [ $a -ne $b ] benar. -gt memeriksa apakah nilai operan kiri lebih besar dari nilai operan kanan; jika ya, maka kondisinya menjadi benar. [ $a -gt $b ] tidak benar. -lt memeriksa apakah nilai operan kiri kurang dari nilai operan kanan; jika ya, maka kondisinya menjadi benar. [ $a -lt $b ] benar. -ge memeriksa apakah nilai operan kiri lebih besar atau sama dengan niai operan kanan jika ya, maka kondisinya menjadi benar. [ $a -ge $b ] tidak benar. -le memeriksa apakah nilai operan kiri kurang dari atau sama dengan nilai operan kanan; jika ya, maka kondisinya menjadi benar. [ $a -le $b ] benar.","title":"Relasional"},{"location":"belajar/shell/operator/#boolean","text":"Operator Boolean berikut ini didukung oleh Bourne Shell. Asumsikan variabel a menampung 5 dan variabel b menampung 3- maka Operator Deskripsi Contoh ! ini adalaha negasi logis. ini membalikkan kondisi benar menjadi salah dan sebaliknya [!false] benar o ini logis atau . jika salah satu operan benar, maka kondisinya menjadi benar. [$a -lt 20 -o $b -gt 100] benar a ini adalah logis dan . jika kedua operan benar, makan kondisi menjadi benar dan jika tidak salah [$a -lt 20 -a $b -gt 100] salah","title":"Boolean"},{"location":"belajar/shell/shebang/","text":"Shebang \u00b6 Shebang itu apasih? Shebang adalah sebuah statement yang kita tentukan di baris pertama pada shell scripts kita. Fungsi-nya apa sih shebang ini? Nah di materi ini kita bakal cari tau kenapa shebang itu cukup penting dan apa fungsi-nya. Nah jadi apa fungsi shebang? Seperti yang saya bilang tadi, shebang adalah statement yang kita tentukan di barisan pertama pada shell scripts kita, fungsi-nya untuk menentukan shell apa yang akan digunakan untuk menjalankan script kita ini. Shebang akan menginstruksikan shell untuk menjalankan script yang di tentukan dengan shell tertentu. Contoh dibawah ini menunjukan untuk menjalankan script for loop dibawah dengan shell Bash (dengan asumsi bahwa bash telah di install di /bin ). #!/bin/bash <- ini adalah shebang for count in { 0 ..10 } ; do echo \"Hitungan $count \" done Output: Hitungan 0 Hitungan 1 Hitungan 2 Hitungan 3 dan seterus-nya Jadi apakah shebang itu penting? Sangat penting, kenapa? saya akan beri contoh seperti di atas dengan shell yang berbeda yaitu Debian Almquist Shell (dash) #!/bin/dash for count in { 0 ..10 } ; do echo \"Hitungan $count \" done Output: Hitungan { 0 ..10 } Loh, Kok bisa output-nya berbeda? karena dash tidak tahu cara-nya mengubah ekspansi {0..10} menjadi sebuah urutan angka. Tidak semua shell memiliki cara kerja dan syntax yang sama, itulah mengapa Shebang cukup penting untuk menunjukan shell apa yang akan digunakan untuk menjalankan script kita ini. Jika script mendeklarasikan dash pada shebang namun saya ingin menggunakan bash bagaimana? Kalian cukup menjalankan-nya dengan mengawali perintah bash. bash /path/ke/file.sh Lalu jika kita tidak menentukan shell apa yang akan digunakan melalui shebang, apa yang akan terjadi? Jika begitu secara otomatis script akan menggunakan shebang #!/bin/sh . #!/bin/sh itu shell apa? itu hanyalah sebuah symlink ke shell tertentu, ini bergantung kepada sistem operasi apa yang digunakan karena pada kebanyakan distro linux symlink sh akan mengarahkan-nya kepada Bash, namun berbeda untuk Debian yang akan mengarahkan-nya kepada dash. Cara cek-nya gimana? kalian cukup menjalankan perintah ls -l /bin/sh di terminal kalian. perintah tersebut akan memberi tahu mengarah kemana symlink tersebut. $ ls -l /bin/sh /bin/sh -> bash # <- Output Karena sh hanyalah symlink, maka dari itu sangatlah di rekomendasikan untuk menggunakan #!/bin/bash dari pada #!/bin/sh untuk menghindari error di shell script kalian.","title":"Shebang"},{"location":"belajar/shell/shebang/#shebang","text":"Shebang itu apasih? Shebang adalah sebuah statement yang kita tentukan di baris pertama pada shell scripts kita. Fungsi-nya apa sih shebang ini? Nah di materi ini kita bakal cari tau kenapa shebang itu cukup penting dan apa fungsi-nya. Nah jadi apa fungsi shebang? Seperti yang saya bilang tadi, shebang adalah statement yang kita tentukan di barisan pertama pada shell scripts kita, fungsi-nya untuk menentukan shell apa yang akan digunakan untuk menjalankan script kita ini. Shebang akan menginstruksikan shell untuk menjalankan script yang di tentukan dengan shell tertentu. Contoh dibawah ini menunjukan untuk menjalankan script for loop dibawah dengan shell Bash (dengan asumsi bahwa bash telah di install di /bin ). #!/bin/bash <- ini adalah shebang for count in { 0 ..10 } ; do echo \"Hitungan $count \" done Output: Hitungan 0 Hitungan 1 Hitungan 2 Hitungan 3 dan seterus-nya Jadi apakah shebang itu penting? Sangat penting, kenapa? saya akan beri contoh seperti di atas dengan shell yang berbeda yaitu Debian Almquist Shell (dash) #!/bin/dash for count in { 0 ..10 } ; do echo \"Hitungan $count \" done Output: Hitungan { 0 ..10 } Loh, Kok bisa output-nya berbeda? karena dash tidak tahu cara-nya mengubah ekspansi {0..10} menjadi sebuah urutan angka. Tidak semua shell memiliki cara kerja dan syntax yang sama, itulah mengapa Shebang cukup penting untuk menunjukan shell apa yang akan digunakan untuk menjalankan script kita ini. Jika script mendeklarasikan dash pada shebang namun saya ingin menggunakan bash bagaimana? Kalian cukup menjalankan-nya dengan mengawali perintah bash. bash /path/ke/file.sh Lalu jika kita tidak menentukan shell apa yang akan digunakan melalui shebang, apa yang akan terjadi? Jika begitu secara otomatis script akan menggunakan shebang #!/bin/sh . #!/bin/sh itu shell apa? itu hanyalah sebuah symlink ke shell tertentu, ini bergantung kepada sistem operasi apa yang digunakan karena pada kebanyakan distro linux symlink sh akan mengarahkan-nya kepada Bash, namun berbeda untuk Debian yang akan mengarahkan-nya kepada dash. Cara cek-nya gimana? kalian cukup menjalankan perintah ls -l /bin/sh di terminal kalian. perintah tersebut akan memberi tahu mengarah kemana symlink tersebut. $ ls -l /bin/sh /bin/sh -> bash # <- Output Karena sh hanyalah symlink, maka dari itu sangatlah di rekomendasikan untuk menggunakan #!/bin/bash dari pada #!/bin/sh untuk menghindari error di shell script kalian.","title":"Shebang"},{"location":"belajar/shell/user-input/","text":"User Input \u00b6 User Input ialah sebuah metode dimana si pengguna / pembuat script akan memasukan data secara manual tidak lagi melalui editing scriptnya . Materi ini penting semisalnya kita mendapatkan tugas biodata dengan hasil inputan sendiri. Oke langsung saja ke materinya Di shell scripting untuk menjadikan sebuah variabel itu inputan dengan method read , dimana ini akan menyimpan data hasil inputan kita. Lalu apakah bagaimana strukturnya? seperti ini echo \"SOME_STRING: \" read variabel Selain itu di shell scripting ada yang namanya prompt mode. Dimana mode ini sama seperti dengan -c , mode prompt bisa di persingkat dengan -p . Mode prompt juga bisa diolah menjadi progam inputan password dimana data input user tidak terlihat dan hanya memiliki akses mengetik saja dengan sintaks -sp , contoh strukturnya seperti ini read -p \"MyName : \" username read -sp \"MyPassword : \" password echo echo \"your name is : $username \" echo \"your password is : $password \" Lalu ada lagi, dimana kondisi ketika kita ingin membuat inputan kita menjadi sebuah array. Bagaimana itu? kita bisa lakukan dengan -a . Bagaimana contohnya? seperti ini contohnya echo \"Array Name : \" read -a name echo \"Names : ${ name [0] } ${ name [1] } ${ name [2] } \"","title":"User Input"},{"location":"belajar/shell/user-input/#user-input","text":"User Input ialah sebuah metode dimana si pengguna / pembuat script akan memasukan data secara manual tidak lagi melalui editing scriptnya . Materi ini penting semisalnya kita mendapatkan tugas biodata dengan hasil inputan sendiri. Oke langsung saja ke materinya Di shell scripting untuk menjadikan sebuah variabel itu inputan dengan method read , dimana ini akan menyimpan data hasil inputan kita. Lalu apakah bagaimana strukturnya? seperti ini echo \"SOME_STRING: \" read variabel Selain itu di shell scripting ada yang namanya prompt mode. Dimana mode ini sama seperti dengan -c , mode prompt bisa di persingkat dengan -p . Mode prompt juga bisa diolah menjadi progam inputan password dimana data input user tidak terlihat dan hanya memiliki akses mengetik saja dengan sintaks -sp , contoh strukturnya seperti ini read -p \"MyName : \" username read -sp \"MyPassword : \" password echo echo \"your name is : $username \" echo \"your password is : $password \" Lalu ada lagi, dimana kondisi ketika kita ingin membuat inputan kita menjadi sebuah array. Bagaimana itu? kita bisa lakukan dengan -a . Bagaimana contohnya? seperti ini contohnya echo \"Array Name : \" read -a name echo \"Names : ${ name [0] } ${ name [1] } ${ name [2] } \"","title":"User Input"},{"location":"belajar/shell/variabel-spesial/","text":"Variabel spesial \u00b6 dalam materi sebelumnya, kita memahami bagaimana berhati-hati saat kita menggunakan karakter non alfanumerik tertentu dalam sebuah variabel, ini karena karakter tersebut digunakan dalam nama variabel shell khusu. variabel ini dicadangkan untuk fungsi tertentu. misalnya, karakter $ mewakili proses id atau PID dari shell echo $$ berikut variabel khusus yang bisa kita gunakan dalam script shell. variabel deskripsi $0 nama file saat ini $# jumlah argumen yang diberikan ke script $* semua argumen dikutip ganda, jika script menermua dua argumen, $* sama dengan $1 $2 $@ semua argumen secara indvidual dikutip ganda, jika skrip menerima dua argumen, $@ ama dengan $1 $2 $? status keluar dari perintah terakhir yang diekseskusi $$ nomor proses dari shell saat ini. ini adalah id proses yang dijalankannya $! nomor proses dari perintah latar belakang terakhir status keluar \u00b6 variabel $? mewakili tatu keluar dari perintah ebelumnya. status keluar adalah nilai numerik yang dikembalikan oleh setiap perintah setelah selesai. sebagai aturan, sebagian besar perintah mengembalikan status keluar 0 jika berhasil, dan jika 1 maka tidak berhasil. beberapa perintah mengembalikan status keluar tambahan karena alasan tertentu, misalnya, beberapa perintah membedakan antara jenis kesalahan dan akan mengembalikan bebrbagai nilai keluar tergantung pada jenis kegagalan. tertentu. contoh variable spesial #!/bin/sh NAMA = \"Belajar\" NAMA2 = \"Shell\" echo $? echo $$ echo \" $NAMA \" echo \" $NAMA2 \"","title":"Variabel Spesial"},{"location":"belajar/shell/variabel-spesial/#variabel-spesial","text":"dalam materi sebelumnya, kita memahami bagaimana berhati-hati saat kita menggunakan karakter non alfanumerik tertentu dalam sebuah variabel, ini karena karakter tersebut digunakan dalam nama variabel shell khusu. variabel ini dicadangkan untuk fungsi tertentu. misalnya, karakter $ mewakili proses id atau PID dari shell echo $$ berikut variabel khusus yang bisa kita gunakan dalam script shell. variabel deskripsi $0 nama file saat ini $# jumlah argumen yang diberikan ke script $* semua argumen dikutip ganda, jika script menermua dua argumen, $* sama dengan $1 $2 $@ semua argumen secara indvidual dikutip ganda, jika skrip menerima dua argumen, $@ ama dengan $1 $2 $? status keluar dari perintah terakhir yang diekseskusi $$ nomor proses dari shell saat ini. ini adalah id proses yang dijalankannya $! nomor proses dari perintah latar belakang terakhir","title":"Variabel spesial"},{"location":"belajar/shell/variabel-spesial/#status-keluar","text":"variabel $? mewakili tatu keluar dari perintah ebelumnya. status keluar adalah nilai numerik yang dikembalikan oleh setiap perintah setelah selesai. sebagai aturan, sebagian besar perintah mengembalikan status keluar 0 jika berhasil, dan jika 1 maka tidak berhasil. beberapa perintah mengembalikan status keluar tambahan karena alasan tertentu, misalnya, beberapa perintah membedakan antara jenis kesalahan dan akan mengembalikan bebrbagai nilai keluar tergantung pada jenis kegagalan. tertentu. contoh variable spesial #!/bin/sh NAMA = \"Belajar\" NAMA2 = \"Shell\" echo $? echo $$ echo \" $NAMA \" echo \" $NAMA2 \"","title":"status keluar"},{"location":"belajar/shell/variabel/","text":"Variabel \u00b6 Variabel, adalah string karakter yang kita beri nilai, nilai yang diberikan dpat berup anka, teks, nama file, perangkat atau jenis data lainnya. variabel tidak lebih dari petunjuk ke data aktual. shell memungkinkan kita untuk membuat, menetapkan dan menghapus variabel. nama variabel hanya boleh berisi huruf( a sampai z atau A sampai Z) angka (0 sampai 9) atau karakter garis bawah ( _ ) dengan peraturan conventional shell, penamaan variabel haru berifat uppercase atau huruf kapital. contoh nama variabel yang vaild _NAMA NAMA_VARIABEL VARIABEL_1 VARIAABEL_KE_2 berikut contoh dari variabel yang tidak valid 1_NAMA -NAMA_VARIABEL VARIABEL1-VARIABEL2 VARIABEL3! alasan kita tidak dapat menggunakan karakter sepert !, &, atau -, karena karakter ini meiliki arti khusus untuk shell. Mendifinsikan variabel \u00b6 variabel didefinisikan sebagai berikut VARIABEL = VALUE contoh diatass mendifinisikan variabel dan memberikan nilai padanya, variabel jenis ini disebut dengan variabel skalar . variabel skalar hanya dapat menampung satu nilai pada satu waktu. shell memungkinkn kita untuk menyimpan nilai apapun yang diingkan dalam sebuah variabel. Mengakses nilai \u00b6 untuk mengakses nilai yang disimpan dalam variabel. awali pemanggila dengan tanda dolar ($) sebagai contoh NAMA = \"james cameroon\" echo $NAMA output james cameroon Variabel read only \u00b6 shell juga menyediakan cara untuk menandai variabel sebagai read-only dengan menggunakan perintah readonly . setelah variabel ditandai, maka nilainya tidak dapat diubah. NAMA = \"adam levine\" readonly NAMA NAMA = \"james cameroon\" jika dijalankan maka akan menghasilkan /bin/sh: NAME: This variable is read only. Variabel unset \u00b6 unset atau menghapus variabel mengarahkan shell untuk menghapus variabel dari daftar variabel yang dilacaknya. setelah kita menghapus variabel. kita dapat mengakses nilai yang disimpan dalam variabel. contoh sintaks dari menghapus variabel unset NAMA_VARIABEL perintah diatas menghapus nilai dari variabel yng ditentukan. NAMA = \"james cameroon\" unset NAMA echo $NAMA contoh di atas tidak mencetak apapun. kita tidak dapat menggunakan perintah unset untuk menghapus variabel yang ditandai readonly","title":"Variabel"},{"location":"belajar/shell/variabel/#variabel","text":"Variabel, adalah string karakter yang kita beri nilai, nilai yang diberikan dpat berup anka, teks, nama file, perangkat atau jenis data lainnya. variabel tidak lebih dari petunjuk ke data aktual. shell memungkinkan kita untuk membuat, menetapkan dan menghapus variabel. nama variabel hanya boleh berisi huruf( a sampai z atau A sampai Z) angka (0 sampai 9) atau karakter garis bawah ( _ ) dengan peraturan conventional shell, penamaan variabel haru berifat uppercase atau huruf kapital. contoh nama variabel yang vaild _NAMA NAMA_VARIABEL VARIABEL_1 VARIAABEL_KE_2 berikut contoh dari variabel yang tidak valid 1_NAMA -NAMA_VARIABEL VARIABEL1-VARIABEL2 VARIABEL3! alasan kita tidak dapat menggunakan karakter sepert !, &, atau -, karena karakter ini meiliki arti khusus untuk shell.","title":"Variabel"},{"location":"belajar/shell/variabel/#mendifinsikan-variabel","text":"variabel didefinisikan sebagai berikut VARIABEL = VALUE contoh diatass mendifinisikan variabel dan memberikan nilai padanya, variabel jenis ini disebut dengan variabel skalar . variabel skalar hanya dapat menampung satu nilai pada satu waktu. shell memungkinkn kita untuk menyimpan nilai apapun yang diingkan dalam sebuah variabel.","title":"Mendifinsikan variabel"},{"location":"belajar/shell/variabel/#mengakses-nilai","text":"untuk mengakses nilai yang disimpan dalam variabel. awali pemanggila dengan tanda dolar ($) sebagai contoh NAMA = \"james cameroon\" echo $NAMA output james cameroon","title":"Mengakses nilai"},{"location":"belajar/shell/variabel/#variabel-read-only","text":"shell juga menyediakan cara untuk menandai variabel sebagai read-only dengan menggunakan perintah readonly . setelah variabel ditandai, maka nilainya tidak dapat diubah. NAMA = \"adam levine\" readonly NAMA NAMA = \"james cameroon\" jika dijalankan maka akan menghasilkan /bin/sh: NAME: This variable is read only.","title":"Variabel read only"},{"location":"belajar/shell/variabel/#variabel-unset","text":"unset atau menghapus variabel mengarahkan shell untuk menghapus variabel dari daftar variabel yang dilacaknya. setelah kita menghapus variabel. kita dapat mengakses nilai yang disimpan dalam variabel. contoh sintaks dari menghapus variabel unset NAMA_VARIABEL perintah diatas menghapus nilai dari variabel yng ditentukan. NAMA = \"james cameroon\" unset NAMA echo $NAMA contoh di atas tidak mencetak apapun. kita tidak dapat menggunakan perintah unset untuk menghapus variabel yang ditandai readonly","title":"Variabel unset"}]}